# GO

## go的调度

https://www.jianshu.com/p/36e246c6153d

go使用的的M:N的调度模型 即**M：N：=内核线程 ：协程**  

防止线程堵塞 空闲 被系统挂起

主要基于三个基本对象上，G，M，P（定义在源码的src/runtime/runtime.h文件中）

1.   G代表一个goroutine对象，每次go调用的时候，都会创建一个G对象

2.   M代表一个线程，每次创建一个M的时候，都会有一个底层线程创建；所有的G任务，最终还是在M上执行

3.   P代表一个处理器，每一个运行的M都必须绑定一个P，就像线程必须在么一个CPU核上执行一样

### g0

每个M都有一个特殊的G，g0。用于执行调度，gc，栈管理等任务，所以g0的栈称为调度栈。g0的栈不会自动增长，不会被gc，来自os线程的栈。

### G状态

go1.10\src\runtime\runtime2.go

- _Gidle: 分配了G，但是没有初始化
- _Grunnable: 在run queue运行队列中，LRQ或者GRQ
- _Grunning: 正在运行指令，有自己的stack。不在runq运行队列中，分配给M和P
- _Gsyscall: 正在执行syscall，而非用户指令，不在runq，分给M，P给找idle的M
- _Gwaiting: block。不在RQ，但是可能会在channel的wait queue等待队列
- _Gdead: unused。在P的gfree list中，不在runq。idle闲置状态
- _Gcopystack: stack扩容或者gc收缩

调度器有确切的 GOMAXPROCS 数量的 P (GOMAXPROCS是一个环境变量和运行时函数, 用来设置程序中的并发度). 为了让 M 执行一个 G, 它必须获得一个P, 然后运行 G 直到停止. G 通过进行诸如 I/O 操作的系统调用, 阻塞一个 channel 操作, 调用 C 函数, 正在被预抢占(pre-emption)或其他一些小的情况来停止. 一个 G 只能在一个安全的地方被预抢占, 在当前的实现中只能在代码发生函数调用的时候发生.

当一个 G 被类似于一个 channel 操作那样阻塞时, 它将被放置在一个队列中, M 将寻找另一个可运行的 G . 如果没有可运行的 G, 则 M 将释放 P 并进入睡眠状态.

当 G 完成系统调用时, 必须重新获取 P. 如果没有 P 可用, 它将被标记为_Grunnable, M 将进入睡眠状态.

当 channel 操作成功时, 它会唤醒另一个 goroutine, 将其标记为_Grunnable, 并且如果有可用的 P, 则唤醒 M 来运行它.

虽然垃圾收集器大多是并发的, 但有几点要暂时停止所有的线程才能安全地转移到下一个收集阶段. 它通过标记所有正在运行的 goroutine 来预抢占. 当他们到达安全点时, G 和 M 将进入睡眠. 当垃圾收集器是唯一剩下的正在运行的 G 时, 它将移动到下一个阶段, 然后唤醒 GOMAXPROC 数量的 M, 它们将各自找到可运行的 G, 并继续下去.

runtime.Gosched 函数促使 M 将当前的 G 放在可运行的 goroutine 列表中, 并从该列表中选择一个新的 G 开始运行.

调度器的两大思想：
一 复用线程：

1.work stealing，当本线程无可运行的G时，尝试从其它县城绑定的P偷取G，而不是销毁线程；

2.hand off，当本线程因为G进行系统调用阻塞是，线程释放绑定的P，把P转移给其它空闲的线程执行；

二 利用并行：
GOMAXPROCS设置P的数量，当GOMAXPROCS大于1时，就最多有GOMAXPROCS个线程处于运行状态，这些线程可能分布在多个CPU核上同时运行，使得并发利用并行。

调度的目的就是防止M堵塞，空闲，系统进程切换。

**防止阻塞**：

​	异步调用

Linux可以通过epoll实现网络调用，统称网络轮询器N（Net Poller）。

1. G1在M上运行，P的LRQ有其他3个G，N空闲；
2. G1进行网络IO，因此被移动到N，M继续从LRQ取其他的G执行。比如G2就被上下文切换到M上；
3. G1结束网络请求，收到响应，G1被移回LRQ，等待切换到M执行。

同步调用

文件IO操作

1. G1在M1上运行，P的LRQ有其他3个G；
2. G1进行同步调用，堵塞M；
3. 调度器将M1与P分离，此时M1下只有G1，没有P。
4. 将P与空闲M2绑定，并从LRQ选择G2切换
5. G1结束堵塞操作，移回LRQ。M1空闲备用。

**防止空闲**

本质是复用线程

1. 两个P，P1，P2
2. 如果P1的G都执行完了，LRQ空，P1就开始任务窃取。
3. 第一种情况，P2 LRQ还有G，则P1从P2窃取了LRQ中一半的G
4. 第二种情况，P2也没有LRQ，P1从GRQ窃取。



**在Go中，线程是运行goroutine的实体，调度器的功能就是把可运行的goroutine分配到工作线程上**

## 协程，线程，进程的区别。

-   进程

进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。

-   线程

线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。

-   协程

协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

## slice扩容

如果切片的容量小于1024个元素，那么扩容的时候slice的cap就在当前容量的基础上翻番，乘以2；一旦元素个数超过1024个元素，增长因子就变成1.25，即每次增加当前容量的四分之一。

如果扩容之后，还没有触及原数组的容量，那么，切片中的指针指向的位置，就还是原数组，如果扩容之后，超过了原数组的容量，那么，Go就会开辟一块新的内存，把原来的值拷贝过来，这种情况丝毫不会影响到原数组。

即大致可以表述如下：

当向切片中添加数据时,如果没有超过容量,直接添加,如果超过容量,自动扩容(成倍增长)

当超过容量,切片指向的就不再原来的数组,而是内存地址中开辟了一个新的数组

## GC

https://www.jianshu.com/p/8b0c0f7772da

https://studygolang.com/articles/12062

### 三色标记

- 灰色：对象已被标记，但这个对象包含的子对象未标记
- 黑色：对象已被标记，且这个对象包含的子对象也已标记，gcmarkBits对应的位为1（该对象不会在本次GC中被清理）
- 白色：对象未被标记，gcmarkBits对应的位为0（该对象将会在本次GC中被清理）

例如，当前内存中有A~F一共6个对象，根对象a,b本身为栈上分配的局部变量，根对象a、b分别引用了对象A、B, 而B对象又引用了对象D，则GC开始前各对象的状态如下图所示:

1. 初始状态下所有对象都是白色的。
2. 接着开始扫描根对象a、b; 由于根对象引用了对象A、B,那么A、B变为灰色对象，接下来就开始分析灰色对象，分析A时，A没有引用其他对象很快就转入黑色，B引用了D，则B转入黑色的同时还需要将D转为灰色，进行接下来的分析。
3. 灰色对象只有D，由于D没有引用其他对象，所以D转入黑色。标记过程结束
4. 最终，黑色的对象会被保留下来，白色对象会被回收掉。

<img src="https:////upload-images.jianshu.io/upload_images/9905654-21959315e05fd033.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/776/format/webp" alt="img" style="zoom:33%;" />



### STW

stop the world是gc的最大性能问题，对于gc而言，需要停止所有的内存变化，即停止所有的goroutine，等待gc结束之后才恢复。

GO的GC是并行GC, 也就是GC的大部分处理和普通的go代码是同时运行的, 这让GO的GC流程比较复杂.

1. Stack scan：Collect pointers from globals and goroutine stacks。收集根对象（全局变量，和G stack），开启写屏障。全局变量、开启写屏障需要STW，G stack只需要停止该G就好，时间比较少。
2. Mark: Mark objects and follow pointers。标记所有根对象, 和根对象可以到达的所有对象不被回收。
3. Mark Termination: Rescan globals/changed stack, finish mark。重新扫描全局变量，和上一轮改变的stack（写屏障），完成标记工作。这个过程需要STW。
4. Sweep: 按标记结果清扫span

目前整个GC流程会进行两次STW(Stop The World), 第一次是Stack scan阶段, 第二次是Mark Termination阶段.

- 第一次STW会准备根对象的扫描, 启动写屏障(Write Barrier)和辅助GC(mutator assist).
- 第二次STW会重新扫描部分根对象, 禁用写屏障(Write Barrier)和辅助GC(mutator assist).

从1.8以后的golang将第一步的stop the world 也取消了，这又是一次优化； 1.9开始, 写屏障的实现使用了Hybrid Write Barrier, 大幅减少了第二次STW的时间.

## **go语言中，new和make的区别**

new 的作用是初始化一个指向类型的指针(*T)

new函数是内建函数，函数定义：func new(Type) *Type

使用new函数来分配空间。传递给new 函数的是一个类型，不是一个值。返回值是 指向这个新分配的零值的指针。

make 的作用是为 slice，map 或 chan 初始化并返回引用(T)。

make函数是内建函数，函数定义：func make(Type, size IntegerType) Type

·        第一个参数是一个类型，第二个参数是长度

·        返回值是一个类型

make(T, args)函数的目的与new(T)不同。它仅仅用于创建 Slice, Map 和 Channel，并且返回类型是 T（不是T*）的一个初始化的（不是零值）的实例

## **go语言中，数组与切片的区别**

(1). 数组
数组是具有固定长度且拥有零个或者多个相同数据类型元素的序列。
数组的长度是数组类型的一部分，所以[3]int 和 [4]int 是两种不同的数组类型。

  数组需要指定大小，不指定也会根据初始化的自动推算出大小，不可改变 ;

  数组是值传递;

  数组是内置(build-in)类型,是一组同类型数据的集合，它是值类型，通过从0开始的下标索引访问元素值。在初始化后长度是固定的，无法修改其长度。当作为方法的参数传入时将复制一份数组而不是引用同一指针。数组的长度也是其类型的一部分，通过内置函数len(array)获取其长度。

  数组定义：var array [10]int

            var array = [5]int{1,2,3,4,5}


(2). 切片
切片表示一个拥有相同类型元素的可变长度的序列。
切片是一种轻量级的数据结构，它有三个属性：指针、长度和容量。

切片不需要指定大小;

切片是地址传递;

切片可以通过数组来初始化，也可以通过内置函数make()初始化 .初始化时len=cap,在追加元素时如果容量cap不足时将按len的2倍扩容；

切片定义：var slice []type = make([]type, len)

## **说说go语言的select机制**

A. select机制用来处理异步IO问题

B. select机制最大的一条限制就是每个case语句里必须是一个IO操作

C. golang在语言级别支持select关键字

##  **说说进程、线程、协程之间的区别**

进程是资源的分配和调度的一个独立单元，而线程是CPU调度的基本单元；

同一个进程中可以包括多个线程；

进程结束后它拥有的所有线程都将销毁，而线程的结束不会影响同个进程中的其他线程的结束；

线程共享整个进程的资源（寄存器、堆栈、上下文），一个进程至少包括一个线程；

进程的创建调用fork或者vfork，而线程的创建调用pthread_create；

线程中执行时一般都要进行同步和互斥，因为他们共享同一进程的所有资源；

进程是资源分配的单位 

线程是操作系统调度的单位 

进程切换需要的资源很最大，效率很低 

线程切换需要的资源一般，效率一般

 协程切换任务资源很小，效率高 

多进程、多线程根据cpu核数不一样可能是并行的 也可能是并发的。

协程的本质就是使用当前进程在不同的函数代码中切换执行，可以理解为并行。 协程是个用户层面的概念，不同协程的模型实现可能是单线程，也可能是多线程。

进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。（全局变量保存在堆中，局部变量及函数保存在栈中）

线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是这样的)。

协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。

一个应用程序一般对应一个进程，一个进程一般有一个主线程，还有若干个辅助线程，线程之间是平行运行的，在线程里面可以开启协程，让程序在特定的时间内运行。

协程和线程的区别是：协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多CPU的能力。

# Java基础

## 基础特性

### 简述java的多态

Java多态可以分为编译时多态和运行时多态。

编译时多态主要指方法的重载，即通过参数列表的不同来区分不同的方法。

运行时多态主要指继承父类和实现接口时，可使用父类引用指向子类对象。

运行时多态的实现：主要依靠方法表，方法表中最先存放的是Object类的方法，接下来是该类的父类的方法，最后是该类本身的方法。如果子类改写了父类的方法，那么子类和父类的那些同名方法共享一个方法表项，都被认作是父类的方法。因此可以实现运行时多态。

### 面向对象的三大特性

1.  继承：对象的一个新类可以从现有的类中派生，派生类可以从它的基类那继承方法和实例变量，且派生类可以修改或新增新的方法使之更适合特殊的需求。
2.  封装：将客观事物抽象成类，每个类可以把自身数据和方法只让可信的类或对象操作，对不可信的进行信息隐藏。
3.  多态：允许不同类的对象对同一消息作出响应。不同对象调用相同方法即使参数也相同，最终表现行为是不一样的。

### Java提供的多态机制？

java提供了两种用于多态的机制，分别是重载与覆盖。

1.  重载：重载是指同一个类中有多个同名的方法，但这些方法有不同的参数，在编译期间就可以确定调用哪个方法。
2.  覆盖：覆盖是指派生类重写基类的方法，使用基类指向其子类的实例对象，或接口的引用变量指向其实现类的实例对象，在程序调用的运行期根据引用变量所指的具体实例对象调用正在运行的那个对象的方法，即需要到运行期才能确定调用哪个方法。

### 简述重载与重写的区别

重写即子类重写父类的方法，方法对应的形参和返回值类型都不能变。

重载即在一个类中，方法名相同，参数类型或数量不同。



### 为什么Java语言不支持多重继承？

1.  为了程序的结构能够更加清晰从而便于维护。假设Java语言支持多重继承，类C继承自类A和类B,如果类A和B都有自定义的成员方法f(),那么当代码中调用类C的f()会产生二义性。Java语言通过实现多个接口间接支持多重继承，接口由于只包含方法定义，不能有方法的实现，类C继承接口A与接口B时即使它们都有方法f(),也不能直接调用方法，需实现具体的f()方法才能调用，不会产生二义性。
2.  多重继承会使类型转换、构造方法的调用顺序变得复杂，会影响到性能。

    


## 集合

### 简述JAVA的List

List是一个有序队列，在JAVA中有两种实现方式:

ArrayList 使用数组实现，是容量可变的非线程安全列表，随机访问快，集合扩容时会创建更大的数组，把原有数组复制到新数组。

LinkedList 本质是双向链表，与 ArrayList 相比插入和删除速度更快，但随机访问元素很慢。

### Java集Collection类型

链表List：ArrayList, Vector, LinkedList

集合Set：Hashset, LinkedHashSet, TreeSet 

表Map：HashMap, TreeMap, HashTable

### 简述JAVA的Set

Set 即集合，该数据结构不允许元素重复且无序。JAVA对Set有三种实现方式：

HashSet 通过 HashMap 实现，HashMap 的 Key 即 HashSet 存储的元素，Value系统自定义一个名为 PRESENT 的 Object 类型常量。判断元素是否相同时，先比较hashCode，相同后再利用equals比较，查询O(1)

LinkedHashSet 继承自 HashSet，通过 LinkedHashMap 实现，使用双向链表维护元素插入顺序。

TreeSet 通过 TreeMap 实现的，底层数据结构是红黑树，添加元素到集合时按照比较规则将其插入合适的位置，保证插入后的集合仍然有序。查询O(logn)

为何HashMap线程不安全

在JDK1.7中，HashMap采用头插法插入元素，因此并发情况下会导致环形链表，产生死循环。

虽然JDK1.8采用了尾插法解决了这个问题，但是并发下的put操作也会使前一个key被后一个key覆盖。

由于HashMap有扩容机制存在，也存在A线程进行扩容后，B线程执行get方法出现失误的情况。

### 简述java的TreeMap

TreeMap是底层利用红黑树实现的Map结构，底层实现是一棵平衡的排序二叉树，由于红黑树的插入、删除、遍历时间复杂度都为O(logN)，所以性能上低于哈希表。但是哈希表无法提供键值对的有序输出，红黑树可以按照键的值的大小有序输出。

### Collection和Collections有什么区别？

1.  Collection是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如List、Set等。
2.  Collections是一个包装类，包含了很多静态方法、不能被实例化，而是作为工具类使用，比如提供的排序方法： Collections.sort(list);  提供的反转方法：Collections.reverse(list)。

### ArrayList、Vector和LinkedList有什么共同点与区别？

1.  ArrayList、Vector和LinkedList都是可伸缩的数组，即可以动态改变长度的数组。
2.  ArrayList和Vector都是基于存储元素的Object[] array来实现的，它们会在内存中开辟一块连续的空间来存储，支持下标、索引访问。但在涉及插入元素时可能需要移动容器中的元素，插入效率较低。当存储元素超过容器的初始化容量大小，ArrayList与Vector均会进行扩容。
3.  Vector是线程安全的，其大部分方法是直接或间接同步的。ArrayList不是线程安全的，其方法不具有同步性质。LinkedList也不是线程安全的。
4.  LinkedList采用双向列表实现，对数据索引需要从头开始遍历，因此随机访问效率较低，但在插入元素的时候不需要对数据进行移动，插入效率较高。

### HashMap和Hashtable有什么区别？

1.  HashMap是Hashtable的轻量级实现，HashMap允许key和value为null，但最多允许一条记录的key为null.而HashTable不允许。
2.  HashTable中的方法是线程安全的，而HashMap不是。在多线程访问HashMap需要提供额外的同步机制。
3.  Hashtable使用Enumeration进行遍历，HashMap使用Iterator进行遍历。

### 如何决定使用HashMap还是TreeMap?

如果对Map进行插入、删除或定位一个元素的操作更频繁，HashMap是更好的选择。如果需要对key集合进行有序的遍历，TreeMap是更好的选择。

### Java中线程安全的基本数据结构有哪些

HashTable: 哈希表的线程安全版，效率低 ConcurrentHashMap：哈希表的线程安全版，效率高，用于替代HashTable Vector：线程安全版Arraylist Stack：线程安全版栈 BlockingQueue及其子类：线程安全版队列

### 简述ArrayList扩容

如果之前ArrayList，添加新元素后的存储空间不够，ArrayList会采用扩容机制，即在内存中申请原空间的1.5倍空间，并把原数组的值复制到新数组上，以此完成扩容。

### HashSet中，equals与hashCode之间的关系？

equals和hashCode这两个方法都是从object类中继承过来的,equals主要用于判断对象的内存地址引用是否是同一个地址；hashCode根据定义的哈希规则将对象的内存地址转换为一个哈希码。HashSet中存储的元素是不能重复的，主要通过hashCode与equals两个方法来判断存储的对象是否相同：

1.  如果两个对象的hashCode值不同，说明两个对象不相同。
2.  如果两个对象的hashCode值相同，接着会调用对象的equals方法，如果equlas方法的返回结果为true，那么说明两个对象相同，否则不相同。

### 简述ConcurrentHashMap

JDK7采用锁分段技术。首先将数据分成 Segment 数据段，然后给每一个数据段配一把锁，当一个线程占用锁访问其中一个段的数据时，其他段的数据也能被其他线程访问。

get 除读到空值不需要加锁。该方法先经过一次再散列，再用这个散列值通过散列运算定位到 Segment，最后通过散列算法定位到元素。 put 须加锁，首先定位到 Segment，然后进行插入操作，第一步判断是否需要对 Segment 里的 HashEntry 数组进行扩容，第二步定位添加元素的位置，然后将其放入数组。

JDK8的改进

1.  取消分段锁机制，采用CAS算法进行值的设置，如果CAS失败再使用 synchronized 加锁添加元素
2.  引入红黑树结构，当某个槽内的元素个数超过8且 Node数组 容量大于 64 时，链表转为红黑树。
3.  使用了更加优化的方式统计集合内的元素数量。

## Java语言具有哪些特点？

1.  Java为纯面向对象的语言。它能够直接反应现实生活中的对象。

2.  具有平台无关性。java利用Java虚拟机运行字节码，无论是在Windows、Linux还是MacOS等其它平台对Java程序进行编译，编译后的程序可在其它平台运行。

3.  Java为解释型语言，编译器把Java代码编译成平台无关的中间代码，然后在JVM上解释运行，具有很好的可移植性。

4.  Java提供了很多内置类库。如对多线程支持，对网络通信支持，最重要的一点是提供了垃圾回收器。

5.  Java具有较好的安全性和健壮性。Java提供了异常处理和垃圾回收机制，去除了C++中难以理解的指针特性。

6.  Java语言提供了对Web应用开发的支持。

    

## 字节序定义以及Java属于哪种字节序？

字节序是指多字节数据在计算机内存中存储或网络传输时个字节的存储顺序。通常由小端和大端两组方式。

1.  小端:低位字节存放在内存的低地址端，高位字节存放在内存的高地址端。
2.  大端：高位字节存放在内存的低地址端，低位字节存放在内存的高地址端。

Java语言的字节序是大端。

## JDK与JRE有什么区别？

1.  JDK：Java开发工具包（Java Development Kit），提供了Java的开发环境和运行环境。
2.  JRE：Java运行环境(Java Runtime Environment)，提供了Java运行所需的环境。

JDK包含了JRE。如果只运行Java程序，安装JRE即可。要编写Java程序需安装JDK.



简述Java访问修饰符

-   default: 默认访问修饰符，在同一包内可见
-   private: 在同一类内可见，不能修饰类
-   protected : 对同一包内的类和所有子类可见，不能修饰类
-   public: 对所有类可见

## 构造方法、成员变量初始化以及静态成员变量三者的初始化顺序？

先后顺序：静态成员变量、成员变量、构造方法。 详细的先后顺序：父类静态变量、父类静态代码块、子类静态变量、子类静态代码块、父类非静态变量、父类非静态代码块、父类构造函数、子类非静态变量、子类非静态代码块、子类构造函数。

## 接口和抽象类的相同点和区别？

相同点:

1.  都不能被实例化。
2.  接口的实现类或抽象类的子类需实现接口或抽象类中相应的方法才能被实例化。

不同点：

1.  接口只能有方法定义，不能有方法的实现，而抽象类可以有方法的定义与实现。
2.  实现接口的关键字为implements,继承抽象类的关键字为extends。一个类可以实现多个接口，只能继承一个抽象类。
3.  当子类和父类之间存在逻辑上的层次结构，推荐使用抽象类，有利于功能的累积。当功能不需要，希望支持差别较大的两个或更多对象间的特定交互行为，推荐使用接口。使用接口能降低软件系统的耦合度，便于日后维护或添加删除方法。

## final、finally和finalize的区别是什么？

1.  final用于声明属性、方法和类，分别表示属性不可变、方法不可覆盖、类不可继承。
2.  finally作为异常处理的一部分，只能在try/catch语句中使用，finally附带一个语句块用来表示这个语句最终一定被执行，经常被用在需要释放资源的情况下。
3.  finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的finalize()方法。当垃圾回收器准备好释放对象占用空间时，首先会调用finalize()方法，并在下一次垃圾回收动作发生时真正回收对象占用的内存。

## 出现在Java程序中的finally代码块是否一定会执行？

当遇到下面情况不会执行。

1.  当程序在进入try语句块之前就出现异常时会直接结束。
2.  当程序在try块中强制退出时，如使用System.exit(0)，也不会执行finally块中的代码。

其它情况下，在try/catch/finally语句执行的时候，try块先执行，当有异常发生，catch和finally进行处理后程序就结束了，当没有异常发生，在执行完finally中的代码后，后面代码会继续执行。值得注意的是，当try/catch语句块中有return时，finally语句块中的代码会在return之前执行。如果try/catch/finally块中都有return语句，finally块中的return语句会覆盖try/catch模块中的return语句。

## Java语言中关键字static的作用是什么？

static的主要作用有两个：

1.  为某种特定数据类型或对象分配与创建对象个数无关的单一的存储空间。
2.  使得某个方法或属性与类而不是对象关联在一起，即在不创建对象的情况下可通过类直接调用方法或使用类的属性。

具体而言static又可分为4种使用方式：

1.  修饰成员变量。用static关键字修饰的静态变量在内存中只有一个副本。只要静态变量所在的类被加载，这个静态变量就会被分配空间，可以使用''类.静态变量''和''对象.静态变量''的方法使用。
2.  修饰成员方法。static修饰的方法无需创建对象就可以被调用。static方法中不能使用this和super关键字，不能调用非static方法，只能访问所属类的静态成员变量和静态成员方法。
3.  修饰代码块。JVM在加载类的时候会执行static代码块。static代码块常用于初始化静态变量。static代码块只会被执行一次。
4.  修饰内部类。static内部类可以不依赖外部类实例对象而被实例化。静态内部类不能与外部类有相同的名字，不能访问普通成员变量，只能访问外部类中的静态成员和静态成员方法。

## Java代码块执行顺序

1.  父类静态代码块（只执行一次）
2.  子类静态代码块（只执行一次）
3.  父类构造代码块
4.  父类构造函数
5.  子类构造代码块
6.  子类构造函数
7.  普通代码块

## Java中一维数组和二维数组的声明方式？

一维数组的声明方式：

1.  type arrayName[]
2.  type[] arrayName

二维数组的声明方式：

1.  type arrayName[][]
2.  type[][] arrayName
3.  type[] arrayName[]

其中type为基本数据类型或类，arrayName为数组名字

## String和StringBuffer有什么区别？

String用于字符串操作，属于不可变类。String对象一旦被创建，其值将不能被改变。而StringBuffer是可变类，当对象创建后，仍然可以对其值进行修改。

## 判等运算符==与equals的区别？

**==** 比较的是引用，equals比较的是内容。

1.  如果变量是基础数据类型，**==** 用于比较其对应值是否相等。如果变量指向的是对象,**==** 用于比较两个对象是否指向同一块存储空间。
2.  equals是Object类提供的方法之一，每个Java类都继承自Object类，所以每个对象都具有equals这个方法。Object类中定义的equals方法内部是直接调用 **==** 比较对象的。但通过覆盖的方法可以让它不是比较引用而是比较数据内容。

## 为什么要把String设计为不变量？

1.  节省空间：字符串常量存储在JVM的字符串池中可以被用户共享。
2.  提高效率:String会被不同线程共享，是线程安全的。在涉及多线程操作中不需要同步操作。
3.  安全：String常被用于用户名、密码、文件名等使用，由于其不可变，可避免黑客行为对其恶意修改。

## 序列化是什么？

序列化是一种将对象转换成字节序列的过程，用于解决在对对象流进行读写操作时所引发的问题。序列化可以将对象的状态写在流里进行网络传输，或者保存到文件、数据库等系统里，并在需要的时候把该流读取出来重新构造成一个相同的对象。

## 简述Java中Class对象

java中对象可以分为实例对象和Class对象，每一个类都有一个Class对象，其包含了与该类有关的信息。

获取Class对象的方法：

-   Class.forName(“类的全限定名”)
-   实例对象.getClass()
-   类名.class

## Java反射机制是什么？

Java反射机制是指在程序的运行过程中可以构造任意一个类的对象、获取任意一个类的成员变量和成员方法、获取任意一个对象所属的类信息、调用任意一个对象的属性和方法。反射机制使得Java具有动态获取程序信息和动态调用对象方法的能力。可以通过以下类调用反射API。

-   Class类：可获得类属性方法
-   Field类：获得类的成员变量
-   Method类：获取类的方法信息
-   Construct类：获取类的构造方法等信息

## 简述注解

Java 注解用于为 Java 代码提供元数据。作为元数据，注解不直接影响你的代码执行，但也有一些类型的注解实际上可以用于这一目的。

其可以用于提供信息给编译器，在编译阶段时给软件提供信息进行相关的处理，在运行时处理写相应代码，做对应操作。

## 简述元注解

元注解可以理解为注解的注解，即在注解中使用，实现想要的功能。其具体分为：

-   @Retention: 表示注解存在阶段是保留在源码，还是在字节码（类加载）或者运行期（JVM中运行）。
-   @Target：表示注解作用的范围。
-   @Documented：将注解中的元素包含到 Javadoc 中去。
-   @Inherited：一个被@Inherited注解了的注解修饰了一个父类，如果他的子类没有被其他注解修饰，则它的子类也继承了父类的注解。
-   @Repeatable：被这个元注解修饰的注解可以同时作用一个对象多次，但是每次作用注解又可以代表不同的含义。

## 简述Java异常的分类

Java异常分为Error（程序无法处理的错误），和Exception（程序本身可以处理的异常）。这两个类均继承Throwable。

Error常见的有StackOverFlowError,OutOfMemoryError等等。

Exception可分为运行时异常和非运行时异常。对于运行时异常，可以利用try catch的方式进行处理，也可以不处理。对于非运行时异常，必须处理，不处理的话程序无法通过编译。

## 简述throw与throws的区别

throw一般是用在方法体的内部，由开发者定义当程序语句出现问题后主动抛出一个异常。

throws一般用于方法声明上，代表该方法可能会抛出的异常列表。

## 简述泛型	

泛型，即“参数化类型”，解决不确定对象具体类型的问题。在编译阶段有效。在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型在类中称为泛型类、接口中称为泛型接口和方法中称为泛型方法。

## 简述泛型擦除

Java编译器生成的字节码是不包涵泛型信息的，泛型类型信息将在编译处理是被擦除，这个过程被称为泛型擦除。

## 简述Java基本数据类型

-   byte: 占用1个字节，取值范围-128 ~ 127
-   short: 占用2个字节，取值范围-2^15^ ~ 2^15^-1
-   int：占用4个字节，取值范围-2^31^ ~ 2^31^-1
-   long：占用8个字节
-   float：占用4个字节
-   double：占用8个字节
-   char: 占用2个字节
-   boolean：占用大小根据实现虚拟机不同有所差异

## 简述自动装箱拆箱

对于Java基本数据类型，均对应一个包装类。

装箱就是自动将基本数据类型转换为包装器类型，如int->Integer

拆箱就是自动将包装器类型转换为基本数据类型，如Integer->int





## 简述抽象类与接口的区别

抽象类：体现的是is-a的关系，如对于man is a person，就可以将person定义为抽象类。

接口：体现的是can的关系。是作为模板实现的。如设置接口fly，plane类和bird类均可实现该接口。

一个类只能继承一个抽象类，但可以实现多个接口。

## 简述Object类常用方法

1.  hashCode：通过对象计算出的散列码。用于map型或equals方法。 需要保证同一个对象多次调用该方法，总返回相同的整型值。
2.  equals：判断两个对象是否一致。需保证equals方法相同对应的对象hashCode也相同。
3.  toString: 用字符串表示该对象
4.  clone:深拷贝一个对象

## 简述内部类及其作用

-   成员内部类：作为成员对象的内部类。可以访问private及以上外部类的属性和方法。外部类想要访问内部类属性或方法时，必须要创建一个内部类对象，然后通过该对象访问内部类的属性或方法。外部类也可访问private修饰的内部类属性。
-   局部内部类：存在于方法中的内部类。访问权限类似局部变量，只能访问外部类的final变量。
-   匿名内部类：只能使用一次，没有类名，只能访问外部类的final变量。
-   静态内部类：类似类的静态成员变量。

## 简述String/StringBuffer与StringBuilder

String类采用利用final修饰的字符数组进行字符串保存，因此不可变。如果对String类型对象修改，需要新建对象，将老字符和新增加的字符一并存进去。

StringBuilder，采用无final修饰的字符数组进行保存，因此可变。但线程不安全。

StringBuffer，采用无final修饰的字符数组进行保存，可理解为实现线程安全的StringBuilder。

## 简述Java序列化与反序列化的实现

序列化：将java对象转化为字节序列，由此可以通过网络对象进行传输。

反序列化：将字节序列转化为java对象。

具体实现：实现Serializable接口，或实现Externalizable接口中的writeExternal()与readExternal()方法。



## fail-fast和fail-safe迭代器的区别是什么？

1.  fail-fast直接在容器上进行，在遍历过程中，一旦发现容器中的数据被修改，就会立刻抛出ConcurrentModificationException异常从而导致遍历失败。常见的使用fail-fast方式的容器有HashMap和ArrayList等。
2.  fail-safe这种遍历基于容器的一个克隆。因此对容器中的内容修改不影响遍历。常见的使用fail-safe方式遍历的容器有ConcurrentHashMap和CopyOnWriteArrayList。

## 拆箱装箱原理

装箱过程是通过调用包装器的valueOf方法实现的，将原值赋给对应类。

拆箱过程是通过调用包装器的 intValue/doubleValue等方法实现，返回基本的数据类型。

## java反射原理

Java会在编译期装载所有的类，并将其元信息保存至Class类对象中。 因此可以设计x.class/x.getClass()/Class.forName()等方法获取Class对象。所以在反射调用Field/Method/Constructor对象时，可根据Class类对象进行进一步操作。

## compator和compatable的区别

Comparable 是一个接口，用于对象内部的比较方式，该接口需要实现的方法是：

```java
public interface Comparable<T> {
    public int compareTo(T o);
}
```

Comapator 也是一个接口，该接口有个compare方法，该接口需要实现的方法是：

```java
public interface Comparator<T> {
    int compare(T o1, T o2);
}
```

除该方法外，comparator还可以实现其他方法。

## 动态代理实现方式

1.  利用JDK反射机制，实现代理接口
2.  利用CGLib，对指定类生成子类，进行代理。

## 简述OOM（out of memory）

当JVM分配内存不够会抛出out of memory异常。 新建大对象时，容易出现OOM异常

## 简述StackOverFlowError

调用栈深度超过限制产生的异常。 一般会在递归调用时出现，比如递归终止条件写的不对

#  Java多线程

## 简述java内存模型（JMM）

java内存模型定义了程序中各种变量的访问规则。其规定所有变量都存储在主内存，线程均有自己的工作内存。 工作内存中保存被该线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作空间进行，不能直接读写主内存数据。操作完成后，线程的工作内存通过缓存一致性协议将操作完的数据刷回主存。

## 简述as-if-serial

编译器等会对原始的程序进行指令重排序和优化。但不管怎么重排序，其结果和用户原始程序输出预定结果一致。

## 简述happens-before八大原则

程序次序规则：一个线程内写在前面的操作先行发生于后面的。

锁定规则： unlock 操作先行发生于后面对同一个锁的 lock 操作。

volatile 规则：对 volatile 变量的写操作先行发生于后面的读操作。

线程启动规则：线程的 start 方法先行发生于线程的每个动作。

线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生。

线程终止规则：线程中所有操作先行发生于对线程的终止检测。

对象终结规则：对象的初始化先行发生于 finalize 方法。

传递性规则：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C

## as-if-serial 和 happens-before 的区别

as-if-serial 保证单线程程序的执行结果不变，happens-before 保证正确同步的多线程程序的执行结果不变。

## 简述线程的可见性

可见性指当一个线程修改了共享变量时，其他线程能够立即得知修改。volatile,synchronized,final都能保证可见性。

## 简述有序性

即虽然多线程存在并发和指令优化等操作，在本线程内观察该线程的所有执行操作是有序的。

## 简述java中volatile关键字作用

1.  保证变量对所有线程的可见性。 当一条线程修改了变量值，新值对于其他线程来说是立即可以得知的。
2.  禁止指令重排序优化。使用 volatile 变量进行写操作，汇编指令带有 lock 前缀，相当于一个内存屏障，编译器不会将后面的指令重排到内存屏障之前。

## java线程的实现方式

1.  实现Runnable接口
2.  继承Thread类。
3.  实现Callable接口

## 简述java线程的状态

线程状态有New, RUNNABLE, BLOCK, WAITING, TIMED_WAITING, THERMINATED

 NEW：新建状态，线程被创建且未启动，此时还未调用 start 方法。

RUNNABLE: 运行状态。其表示线程正在JVM中执行，但是这个执行，不一定真的在跑，也可能在排队等CPU。

BLOCKED：阻塞状态。线程等待获取锁，锁还没获得。

WAITING: 等待状态。线程内run方法运行完语句Object.wait()/Thread.join()进入该状态。

TIMED_WAITING：限期等待。在一定时间之后跳出状态。调用Thread.sleep(long) Object.wait(long) Thread.join(long)进入状态。其中这些参数代表等待的时间。

TERMINATED：结束状态。线程调用完run方法进入该状态。

## 简述线程通信的方式

1.  volatile 关键词修饰变量，保证所有线程对变量访问的可见性。
2.  synchronized关键词。确保多个线程在同一时刻只能有一个处于方法或同步块中。
3.  wait/notify方法
4.  IO通信

## 线程池

### 线程池类型

1.  newCachedThreadPool 可缓存线程池，可设置最小线程数和最大线程数，线程空闲1分钟后自动销毁。
2.  newFixedThreadPool 指定工作线程数量线程池。
3.  newSingleThreadExecutor 单线程Executor。
4.  newScheduleThreadPool 支持定时任务的指定工作线程数量线程池。
5.  newSingleThreadScheduledExecutor 支持定时任务的单线程Executor。

### 简述线程池

没有线程池的情况下，多次创建，销毁线程开销比较大。如果在开辟的线程执行完当前任务后执行接下来任务，复用已创建的线程，降低开销、控制最大并发数。

线程池创建线程时，会将线程封装成工作线程 Worker，Worker 在执行完任务后还会循环获取工作队列中的任务来执行。

将任务派发给线程池时，会出现以下几种情况

1.  核心线程池未满，创建一个新的线程执行任务。
2.  如果核心线程池已满，工作队列未满，将线程存储在工作队列。
3.  如果工作队列已满，线程数小于最大线程数就创建一个新线程处理任务。
4.  如果超过大小线程数，按照拒绝策略来处理任务。

### 线程池参数

1.  corePoolSize：常驻核心线程数。超过该值后如果线程空闲会被销毁。
2.  maximumPoolSize：线程池能够容纳同时执行的线程最大数。
3.  keepAliveTime：线程空闲时间，线程空闲时间达到该值后会被销毁，直到只剩下 corePoolSize 个线程为止，避免浪费内存资源。
4.  workQueue：工作队列。
5.  threadFactory：线程工厂，用来生产一组相同任务的线程。
6.  handler：拒绝策略。有以下几种拒绝策略：

-   AbortPolicy：丢弃任务并抛出异常
-   CallerRunsPolicy： 重新尝试提交该任务
-   DiscardOldestPolicy 抛弃队列里等待最久的任务并把当前任务加入队列
-   DiscardPolicy 表示直接抛弃当前任务但不抛出异常。

### 线程池创建方法

1.  newFixedThreadPool，创建固定大小的线程池。
2.  newSingleThreadExecutor，使用单线程线程池。
3.  newCachedThreadPool，maximumPoolSize 设置为 Integer 最大值，工作完成后会回收工作线程
4.  newScheduledThreadPool：支持定期及周期性任务执行，不回收工作线程。
5.  newWorkStealingPool：一个拥有多个任务队列的线程池。

### 简述线程池的状态

-   Running：能接受新提交的任务，也可以处理阻塞队列的任务。
-   Shutdown：不再接受新提交的任务，但可以处理存量任务，线程池处于running时调用shutdown方法，会进入该状态。
-   Stop：不接受新任务，不处理存量任务，调用shutdownnow进入该状态。
-   Tidying：所有任务已经终止了，worker_count（有效线程数）为0。
-   Terminated：线程池彻底终止。在tidying模式下调用terminated方法会进入该状态。

## 谈一谈ThreadLocal

ThreadLocal 是线程共享变量。ThreadLoacl 有一个静态内部类 ThreadLocalMap，其 Key 是 ThreadLocal 对象，值是 Entry 对象，ThreadLocalMap是每个线程私有的。

-   set 给ThreadLocalMap设置值。
-   get 获取ThreadLocalMap。
-   remove 删除ThreadLocalMap类型的对象。

存在的问题

1.  对于线程池，由于线程池会重用 Thread 对象，因此与 Thread 绑定的 ThreadLocal 也会被重用，造成一系列问题。
2.  内存泄漏。由于 ThreadLocal 是弱引用，但 Entry 的 value 是强引用，因此当 ThreadLocal 被垃圾回收后，value 依旧不会被释放，产生内存泄漏。

## 聊聊你对java并发包下unsafe类的理解

对于 Java 语言，没有直接的指针组件，一般也不能使用偏移量对某块内存进行操作。这些操作相对来讲是安全（safe）的。

Java 有个类叫 `Unsafe` 类，这个类类使 Java 拥有了像 C 语言的指针一样操作内存空间的能力，同时也带来了指针的问题。这个类可以说是 Java 并发开发的基础。

## JAVA中的乐观锁与CAS算法

对于乐观锁，开发者认为数据发送时发生并发冲突的概率不大，所以读操作前不上锁。

到了写操作时才会进行判断，数据在此期间是否被其他线程修改。如果发生修改，那就返回写入失败；如果没有被修改，那就执行修改操作，返回修改成功。

乐观锁一般都采用 Compare And Swap（CAS）算法进行实现。顾名思义，该算法涉及到了两个操作，比较（Compare）和交换（Swap）。

CAS 算法的思路如下：

1.  该算法认为不同线程对变量的操作时产生竞争的情况比较少。
2.  该算法的核心是对当前读取变量值 E 和内存中的变量旧值 V 进行比较。
3.  如果相等，就代表其他线程没有对该变量进行修改，就将变量值更新为新值 N。
4.  如果不等，就认为在读取值 E 到比较阶段，有其他线程对变量进行过修改，不进行任何操作。

## ABA问题及解决方法简述

CAS 算法是基于值来做比较的，如果当前有两个线程，一个线程将变量值从 A 改为 B ，再由 B 改回为 A ，当前线程开始执行 CAS 算法时，就很容易认为值没有变化，误认为读取数据到执行 CAS 算法的期间，没有线程修改过数据。

juc 包提供了一个 AtomicStampedReference，即在原始的版本下加入版本号戳，解决 ABA 问题。

## 简述常见的Atomic类

在很多时候，我们需要的仅仅是一个简单的、高效的、线程安全的++或者--方案，使用synchronized关键字和lock固然可以实现，但代价比较大，此时用原子类更加方便。 基本数据类型的原子类有：

-   AtomicInteger 原子更新整形
-   AtomicLong 原子更新长整型
-   AtomicBoolean 原子更新布尔类型

Atomic数组类型有：

-   AtomicIntegerArray 原子更新整形数组里的元素
-   AtomicLongArray 原子更新长整型数组里的元素
-   AtomicReferenceArray 原子更新引用类型数组里的元素。

Atomic引用类型有

-   AtomicReference 原子更新引用类型
-   AtomicMarkableReference 原子更新带有标记位的引用类型，可以绑定一个 boolean 标记
-   AtomicStampedReference 原子更新带有版本号的引用类型

FieldUpdater类型：

-   AtomicIntegerFieldUpdater 原子更新整形字段的更新器
-   AtomicLongFieldUpdater 原子更新长整形字段的更新器
-   AtomicReferenceFieldUpdater 原子更新引用类型字段的更新器

## 简述Atomic类基本实现原理

以AtomicIntger 为例： 方法getAndIncrement：以原子方式将当前的值加1，具体实现为：

1.  在 for 死循环中取得 AtomicInteger 里存储的数值
2.  对 AtomicInteger 当前的值加 1
3.  调用 compareAndSet 方法进行原子更新
4.  先检查当前数值是否等于 expect
5.  如果等于则说明当前值没有被其他线程修改，则将值更新为 next，
6.  如果不是会更新失败返回 false，程序会进入 for 循环重新进行 compareAndSet 操作。

## 简述CountDownLatch

countDownLatch这个类使一个线程等待其他线程各自执行完毕后再执行。 是通过一个计数器来实现的，计数器的初始值是线程的数量。每当一个线程执行完毕后，调用countDown方法，计数器的值就减1，当计数器的值为0时，表示所有线程都执行完毕，然后在等待的线程就可以恢复工作了。 只能一次性使用，不能reset。

## 简述CyclicBarrier

CyclicBarrier 主要功能和countDownLatch类似，也是通过一个计数器，使一个线程等待其他线程各自执行完毕后再执行。但是其可以重复使用（reset）。

## 简述Semaphore

Semaphore即信号量。 Semaphore 的构造方法参数接收一个 int 值，设置一个计数器，表示可用的许可数量即最大并发数。使用 acquire 方法获得一个许可证，计数器减一，使用 release 方法归还许可，计数器加一。如果此时计数器值为0,线程进入休眠。

## 简述Exchanger

Exchanger类可用于两个线程之间交换信息。可简单地将Exchanger对象理解为一个包含两个格子的容器，通过exchanger方法可以向两个格子中填充信息。线程通过exchange 方法交换数据，第一个线程执行 exchange 方法后会阻塞等待第二个线程执行该方法。当两个线程都到达同步点时这两个线程就可以交换数据当两个格子中的均被填充时，该对象会自动将两个格子的信息交换，然后返回给线程，从而实现两个线程的信息交换。

## synchronized

### synchronized关键字作用

保证只有一个线程可以获取对象的锁,并执行代码块,其他线程不能在该线程执行代码块时执行。

### Synchronized底层实现原理

Java 对象底层都关联一个的 monitor，使用 synchronized 时 JVM 会根据使用环境找到对象的 monitor，根据 monitor 的状态进行加解锁的判断。如果成功加锁就成为该 monitor 的唯一持有者，monitor 在被释放前不能再被其他线程获取。

synchronized在JVM编译后会产生monitorenter 和 monitorexit 这两个字节码指令，获取和释放 monitor。这两个字节码指令都需要一个引用类型的参数指明要锁定和解锁的对象，对于同步普通方法，锁是当前实例对象；对于静态同步方法，锁是当前类的 Class 对象；对于同步方法块，锁是 synchronized 括号里的对象。

执行 monitorenter 指令时，首先尝试获取对象锁。如果这个对象没有被锁定，或当前线程已经持有锁，就把锁的计数器加 1，执行 monitorexit 指令时会将锁计数器减 1。一旦计数器为 0 锁随即就被释放。

### Synchronized关键词使用方法

1.  直接修饰某个实例方法
2.  直接修饰某个静态方法
3.  修饰代码块

### synchronized和lock的区别

1.  Synchronized是关键字，内置语言实现，即其定义的层次在JVM上，Lock是接口，需要具体实现类，比如ReentrantLock。
2.  Synchronized在线程发生异常时JVM会自动释放锁。Lock不会，所以需要在finally语句段中实现释放锁逻辑。
3.  Synchronized可重入 不可中断 非公平。Lock:可重入 可判断 可公平。

## 锁

### 锁升级过程

1.  无锁状态。最开始处于无锁状态。
2.  偏向锁。如果被一个线程持有，变成偏向锁状态。
3.  轻量级锁。如果该偏向锁被另一个线程争抢，锁升级为轻量级锁。
4.  重量级锁。轻量级锁继续升级，变为重量级锁状态。

#### 简述java偏向锁

JDK 1.6 中提出了偏向锁的概念。该锁提出的原因是，开发者发现多数情况下锁并不存在竞争，一把锁往往是由同一个线程获得的。偏向锁并不会主动释放，这样每次偏向锁进入的时候都会判断该资源是否是偏向自己的，如果是偏向自己的则不需要进行额外的操作，直接可以进入同步操作。

其申请流程为：

1.  首先需要判断对象的 Mark Word 是否属于偏向模式，如果不属于，那就进入轻量级锁判断逻辑。否则继续下一步判断；
2.  判断目前请求锁的线程 ID 是否和偏向锁本身记录的线程 ID 一致。如果一致，继续下一步的判断，如果不一致，跳转到步骤4；
3.  判断是否需要重偏向。如果不用的话，直接获得偏向锁；
4.  利用 CAS 算法将对象的 Mark Word 进行更改，使线程 ID 部分换成本线程 ID。如果更换成功，则重偏向完成，获得偏向锁。如果失败，则说明有多线程竞争，升级为轻量级锁。

### 简述轻量级锁

轻量级锁是为了在没有竞争的前提下减少重量级锁出现并导致的性能消耗。

其申请流程为：

1.  如果同步对象没有被锁定，虚拟机将在当前线程的栈帧中建立一个锁记录空间，存储锁对象目前 Mark Word 的拷贝。
2.  虚拟机使用 CAS 尝试把对象的 Mark Word 更新为指向锁记录的指针
3.  如果更新成功即代表该线程拥有了锁，锁标志位将转变为 00，表示处于轻量级锁定状态。
4.  如果更新失败就意味着至少存在一条线程与当前线程竞争。虚拟机检查对象的 Mark Word 是否指向当前线程的栈帧
5.  如果指向当前线程的栈帧，说明当前线程已经拥有了锁，直接进入同步块继续执行
6.  如果不是则说明锁对象已经被其他线程抢占。
7.  如果出现两条以上线程争用同一个锁，轻量级锁就不再有效，将膨胀为重量级锁，锁标志状态变为 10，此时Mark Word 存储的就是指向重量级锁的指针，后面等待锁的线程也必须阻塞。

### 简述锁优化策略

即自适应自旋、锁消除、锁粗化、锁升级等策略偏。

#### 简述java的自旋锁

线程获取锁失败后，可以采用这样的策略，可以不放弃 CPU ，不停的重试内重试，这种操作也称为自旋锁

#### 简述自适应自旋锁

自适应自旋锁自旋次数不再人为设定，通常由前一次在同一个锁上的自旋时间及锁的拥有者的状态决定。

#### 简述锁粗化

锁粗化的思想就是扩大加锁范围，避免反复的加锁和解锁。

### 简述锁消除

锁消除是一种更为彻底的优化，在编译时，java编译器对运行上下文进行扫描，去除不可能存在共享资源竞争的锁。

#### 简述Lock与ReentrantLock

Lock 接是 java并发包的顶层接口。

可重入锁 ReentrantLock 是 Lock 最常见的实现，与 synchronized 一样可重入。ReentrantLock 在默认情况下是非公平的，可以通过构造方法指定公平锁。一旦使用了公平锁，性能会下降。

## 简述AQS

AQS（AbstractQuenedSynchronizer）抽象的队列式同步器。 AQS是将每一条请求共享资源的线程封装成一个锁队列的一个结点（Node），来实现锁的分配。 AQS是用来构建锁或其他同步组件的基础框架，它使用一个 volatile int state 变量作为共享资源，如果线程获取资源失败，则进入同步队列等待；如果获取成功就执行临界区代码，释放资源时会通知同步队列中的等待线程。

子类通过继承同步器并实现它的抽象方法getState、setState 和 compareAndSetState对同步状态进行更改。

### AQS获取独占锁/释放独占锁原理

获取：（acquire）

1.  调用 tryAcquire 方法安全地获取线程同步状态，获取失败的线程会被构造同步节点并通过 addWaiter 方法加入到同步队列的尾部，在队列中自旋。
2.  调用 acquireQueued 方法使得该节点以死循环的方式获取同步状态，如果获取不到则阻塞。

释放：（release）

1.  调用 tryRelease 方法释放同步状态
2.  调用 unparkSuccessor 方法唤醒头节点的后继节点，使后继节点重新尝试获取同步状态。

### AQS获取共享锁/释放共享锁原理

获取锁（acquireShared）

1.  调用 tryAcquireShared 方法尝试获取同步状态，返回值不小于 0 表示能获取同步状态。

释放（releaseShared）

1.  释放，并唤醒后续处于等待状态的节点。

## 简述三色标记法

三色标记法是垃圾收集器CMS和G1使用的标记方法，该方法把对象分为三种颜色：

1.  白色，该对象尚被未访问。
2.  灰色，该对象已被访问，但该对象引用的其他对象并没有被访问。
3.  黑色，该对象和引用的其他对象均被访问。

因此，对三色标记法来说，所有对象都可以看作由白色集合，黑色集合，灰色集合组成。。通过这种标记方法的访问过程如下：

1.  初始所有对象均在白色集合
2.  将GC root直接引用的对象移动至灰色集合。
3.  从灰色集合中取出一个对象，将该对象引用的白色集合对象，移动至灰色集合
4.  移动完成后，将该对象移动至黑色集合
5.  重复3-4操作。

## threadlocal应用场景

对于数据库中，每个线程通过threadlocal维护自己和该线程对应客户端对于数据库的连接。

## 为什么threadlocal要用弱引用

为了保证当使用完成后，该threadlocal可以被JVM回收，不会产生内存泄漏的情况。

# 计算机网络

## 协议

### 简述OSI七层协议

OSI七层协议包括：物理层，数据链路层，网络层，运输层，会话层，表示层， 应用层

### 简述TCP/IP五层协议

TCP/IP五层协议包括：物理层，数据链路层，网络层，运输层，应用层

### 物理层有什么作用

主要解决两台物理机之间的通信，通过二进制比特流的传输来实现，二进制数据表现为电流电压上的强弱，到达目的地再转化为二进制机器码。网卡、集线器工作在这一层。

### 数据链路层有什么作用

在不可靠的物理介质上提供可靠的传输，接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层。这一层在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路。提供物理地址寻址功能。交换机工作在这一层。

### 网络层有什么作用

将网络地址翻译成对应的物理地址，并决定如何将数据从发送方路由到接收方，通过路由选择算法为分组通过通信子网选择最佳路径。路由器工作在这一层。

### 传输层有什么作用

传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。

### 会话层有什么作用

建立会话：身份验证，权限鉴定等； 保持会话：对该会话进行维护，在会话维持期间两者可以随时使用这条会话传输局； 断开会话：当应用程序或应用层规定的超时时间到期后，OSI会话层才会释放这条会话。

### 表示层有什么作用

对数据格式进行编译，对收到或发出的数据根据应用层的特征进行处理，如处理为文字、图片、音频、视频、文档等，还可以对压缩文件进行解压缩、对加密文件进行解密等。

### 应用层有什么作用

提供应用层协议，如HTTP协议，FTP协议等等，方便应用程序之间进行通信。

## TCP和UDP

### TCP与UDP区别

TCP作为面向流的协议，提供可靠的、面向连接的运输服务，并且提供点对点通信 

UDP作为面向报文的协议，不提供可靠交付，并且不需要连接，不仅仅对点对点，也支持多播和广播

### 为何TCP可靠

TCP有三次握手建立连接，四次挥手关闭连接的机制。 除此之外还有滑动窗口和拥塞控制算法。最最关键的是还保留超时重传的机制。 对于每份报文也存在校验，保证每份报文可靠性。

### TCP三次握手过程

1.  第一次握手:客户端将标志位SYN置为1，随机产生一个值序列号seq=x，并将该数据包发送给服务端，客户端 进入syn_sent状态，等待服务端确认。
2.  第二次握手:服务端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务端将标志位SYN和 ACK都置为1，ack=x+1,随机产生一个值seq=y，并将该数据包发送给客户端以确认连接请求，服务端进入syn_rcvd状态。
3.  第三次握手:客户端收到确认后检查,如果正确则将标志位ACK为1，ack=y+1，并将该数据包发送给服务端，服务端进行检查如果正确则连接建立成功，客户端和服务端进入established状态，完成三次握手，随后客户端和服务端之间可以开始传输 数据了

### 为什么TCP握手需要三次，两次行不行？

不行。TCP进行可靠传输的关键就在于维护一个序列号，三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值。

如果只是两次握手， 至多只有客户端的起始序列号能被确认， 服务器端的序列号则得不到确认。

### 简述半连接队列

TCP握手中，当服务器处于SYN_RCVD 状态，服务器会把此种状态下请求连接放在一个队列里，该队列称为半连接队列。

### 简述SYN攻击

SYN攻击即利用TCP协议缺陷，通过发送大量的半连接请求，占用半连接队列，耗费CPU和内存资源。

优化方式：

1.  缩短SYN Timeout时间
2.  记录IP，若连续受到某个IP的重复SYN报文，从这个IP地址来的包会被一概丢弃。

### TCP四次挥手过程

1.  第一次挥手：客户端发送一个FIN，用来关闭客户端到服务端的数据传送，客户端进入fin*wait*1状态。
2.  第二次挥手：服务端收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1，服务端进入Close_wait状态。此时TCP连接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。
3.  第三次挥手：服务端发送一个FIN，用来关闭服务端到客户端的数据传送，服务端进入Last_ack状态。
4.  第四次挥手：客户端收到FIN后，客户端进入Time_wait状态，接着发送一个ACK给服务端，确认后，服务端进入Closed状态，完成四次挥手。

### 为什么四次挥手释放连接时需要等待2MSL

MSL即报文最大生存时间。设置2MSL可以保证上一次连接的报文已经在网络中消失，不会出现与新TCP连接报文冲突的情况。

### 简述TCP协议的滑动窗口

滑动窗口是传输层进行流量控制的一种措施，接收方通过通告发 送方自己的窗口大小，从而控制发送方的发送速度，防止发送方发送速度过快而导致自己被淹没。

### 简述TCP协议的拥塞控制

拥塞是指一个或者多个交换点的数据报超载，TCP又会有重传机制，导致过载。 为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量.

当cwnd < ssthresh 时，使用慢开始算法。 当cwnd > ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。 当cwnd = ssthresh 时，即可使用慢开始算法，也可使用拥塞避免算法。

慢开始：由小到大逐渐增加拥塞窗口的大小，每接一次报文，cwnd指数增加。

拥塞避免：cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1。

快恢复之前的策略：发送方判断网络出现拥塞，就把ssthresh设置为出现拥塞时发送方窗口值的一半，继续执行慢开始，之后进行拥塞避免。

快恢复：发送方判断网络出现拥塞，就把ssthresh设置为出现拥塞时发送方窗口值的一半，并把cwnd设置为ssthresh的一半，之后进行拥塞避免。

### 简述快重传

如果在超时重传定时器溢出之前，接收到连续的三个重复冗余ACK，发送端便知晓哪个报文段在传输过程中丢失了，于是重发该报文段，不需要等待超时重传定时器溢出再发送该报文。

### 为何UDP不可靠

UDP面向数据报无连接的，数据报发出去，就不保留数据备份了。 仅仅在IP数据报头部加入校验和复用。

 UDP没有服务器和客户端的概念。 

UDP报文过长的话是交给IP切成小段，如果某段报废报文就废了。

### 简述TCP粘包现象

TCP是面向流协议，发送的单位是字节流，因此会将多个小尺寸数据被封装在一个tcp报文中发出去的可能性。 可以简单的理解成客户端调用了两次send，服务器端一个recv就把信息都读出来了。

### TCP粘包现象处理方法

固定发送信息长度

在两个信息之间加入分隔符。

## DNS

### 简述DNS协议

DNS协议是基于UDP的应用层协议，它的功能是根据用户输入的域名，解析出该域名对应的IP地址，从而给客户端进行访问。

### 简述DNS解析过程

1、客户机发出查询请求，在本地计算机缓存查找，若没有找到，就会将请求发送给本地dns服务器

2、本地dns服务器会在自己的区域里面查找，找到即根据此记录进行解析，若没有找到，就会在本地的缓存里面查找

3、本地服务器没有找到客户机查询的信息，就会将此请求发送到根域名dns服务器

4、根域名服务器解析客户机请求的根域部分，它把包含的下一级的dns服务器的地址返回到客户机的dns服务器地址

5、客户机的dns服务器根据返回的信息接着访问下一级的dns服务器

6、这样递归的方法一级一级接近查询的目标，最后在有目标域名的服务器上面得到相应的IP信息

7、客户机的本地的dns服务器会将查询结果返回给我们的客户机

8、客户机根据得到的ip信息访问目标主机，完成解析过程

### 简述DNS劫持

DNS是指将网页域名翻译为对应的IP的一种方法。DNS劫持指攻击者篡改结果，使用户对域名的解析IP变成了另一个IP。

### 浏览器中输入一个网址后，具体发生了什么

1.  进行DNS解析操作，根据DNS解析的结果查到服务器IP地址
2.  通过ip寻址和arp，找到服务器，并利用三次握手建立TCP连接
3.  浏览器生成HTTP报文，发送HTTP请求，等待服务器响应
4.  服务器处理请求，并返回给浏览器
5.  根据HTTP是否开启长连接，进行TCP的挥手过程
6.  浏览器根据收到的静态资源进行页面渲染

## Http

### 简述HTTP协议

http协议是超文本传输协议。它是基于TCP协议的应用层传输协议，即客户端和服务端进行数据传输的一种规则。该协议本身HTTP 是一种无状态的协议。

### 简述cookie

HTTP 协议本身是无状态的，为了使其能处理更加复杂的逻辑，HTTP/1.1 引入 Cookie 来保存状态信息。

Cookie是由服务端产生的，再发送给客户端保存，当客户端再次访问的时候，服务器可根据cookie辨识客户端是哪个，以此可以做个性化推送，免账号密码登录等等。

### 简述session

session用于标记特定客户端信息，存在在服务器的一个文件里。 一般客户端带Cookie对服务器进行访问，可通过cookie中的session id从整个session中查询到服务器记录的关于客户端的信息。

### 简述http状态码和对应的信息

1XX：接收的信息正在处理

2XX：请求正常处理完毕

3XX：重定向

4XX：客户端错误

5XX：服务端错误

常见错误码： 301：永久重定向 302：临时重定向 304：资源没修改，用之前缓存就行 400：客户端请求的报文有错误 403：表示服务器禁止访问资源 404：表示请求的资源在服务器上不存在或未找到

### 转发和重定向的区别

转发是服务器行为。服务器直接向目标地址访问URL,将相应内容读取之后发给浏览器，用户浏览器地址栏URL不变，转发页面和转发到的页面可以共享request里面的数据。

重定向是利用服务器返回的状态码来实现的，如果服务器返回301或者302，浏览器收到新的消息后自动跳转到新的网址重新请求资源。用户的地址栏url会发生改变，而且不能共享数据。

### 简述http1.0

规定了请求头和请求尾，响应头和响应尾（get post）

每一个请求都是一个单独的连接，做不到连接的复用

### 简述http1.1的改进

HTTP1.1默认开启长连接，在一个TCP连接上可以传送多个HTTP请求和响应。使用 TCP 长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。

支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。

服务端无法主动push

### 简述HTTP短连接与长连接区别

HTTP中的长连接短连接指HTTP底层TCP的连接。

短连接： 客户端与服务器进行一次HTTP连接操作，就进行一次TCP连接，连接结束TCP关闭连接。

长连接：如果HTTP头部带有参数keep-alive，即开启长连接网页完成打开后，底层用于传输数据的TCP连接不会直接关闭，会根据服务器设置的保持时间保持连接，保持时间过后连接关闭。

### 简述http2.0的改进

提出多路复用。多路复用前，文件时串行传输的，请求a文件，b文件只能等待，并且连接数过多。引入多路复用，a文件b文件可以同时传输。

引入了二进制数据帧。其中帧对数据进行顺序标识，有了序列id，服务器就可以进行并行传输数据。

### http与https的区别

http所有传输的内容都是明文，并且客户端和服务器端都无法验证对方的身份。

https具有安全性的ssl加密传输协议，加密采用对称加密， https协议需要到ca申请证书，一般免费证书很少，需要交费。

### 简述TLS/SSL, HTTP, HTTPS的关系

SSL全称为Secure Sockets Layer即安全套接层，其继任为TLS为Transport Layer Security传输层安全协议，均用于在传输层为数据通讯提供安全支持。

可以将HTTPS协议简单理解为HTTP协议＋TLS/SSL

### https的连接过程

1.  浏览器将支持的加密算法信息发给服务器
2.  服务器选择一套浏览器支持的加密算法，以证书的形式回发给浏览器
3.  客户端(SSL/TLS)解析证书验证证书合法性，生成对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，用服务器的公钥对客户端密钥进行非对称加密。
4.  客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端对称密钥发送给服务器
5.  服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。
6.  服务器将加密后的密文发送给客户端
7.  客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成

## GET和Post

### Get与Post区别

Get：指定资源请求数据，刷新无害，Get请求的数据会附加到URL中，传输数据的大小受到url的限制。

Post：向指定资源提交要被处理的数据。刷新会使数据会被重复提交。post在发送数据前会先将请求头发送给服务器进行确认，然后才真正发送数据。

### Get方法参数有大小限制吗

一般HTTP协议里并不限制参数大小限制。但一般由于get请求是直接附加到地址栏里面的，由于浏览器地址栏有长度限制，因此使GET请求在浏览器实现层面上看会有长度限制。

### 了解REST API吗

REST API全称为表述性状态转移（Representational State Transfer，REST）即利用HTTP中get、post、put、delete以及其他的HTTP方法构成REST中数据资源的增删改查操作：

-   Create ： POST
-   Read ： GET
-   Update ： PUT/PATCH
-   Delete： DELETE

### http请求包含了什么

包含：请求方法字段、URL字段、HTTP协议版本

产生请求的浏览器类型，请求数据，主机地址。

### Put与Delete区别

Put规定默认为更新某一资源，和Post一样，一般该操作会对服务器资源进行改变 

Delete规定默认为删除某一资源，和Post一样，一般该操作会对服务器资源进行改变

6.  

# 操作系统

## 什么是操作系统？请简要概述一下

操作系统是管理计算机硬件和软件资源的计算机程序，提供一个计算机用户与计算机硬件系统之间的接口。

向上对用户程序提供接口，向下接管硬件资源。

操作系统本质上也是一个软件，作为最接近硬件的系统软件，负责处理器管理、存储器管理、设备管理、文件管理和提供用户接口。

## 操作系统有哪些分类？

操作系统常规可分为批处理操作系统、分时操作系统、实时操作系统。

若一个操作系统兼顾批操作和分时的功能，则称该系统为通用操作系统。

常见的通用操作系统有：Windows、Linux、MacOS等。

## 实时操作系统的概念

实时操作系统（Real-time operating system, RTOS），又称即时操作系统，它会按照排序运行、管理系统资源，并为开发应用程序提供一致的基础。 实时操作系统与一般的操作系统相比，最大的特色就是“实时性”，如果有一个任务需要执行，实时操作系统会马上（在较短时间内）执行该任务，不会有较长的延时。这种特性保证了各个任务的及时执行。

## 什么是内核态和用户态？

为了避免操作系统和关键数据被用户程序破坏，将处理器的执行状态分为内核态和用户态。

内核态是操作系统管理程序执行时所处的状态，能够执行包含特权指令在内的一切指令，能够访问系统内所有的存储空间。

用户态是用户程序执行时处理器所处的状态，不能执行特权指令，只能访问用户地址空间。

用户程序运行在用户态,操作系统内核运行在内核态。

## 如何实现内核态和用户态的切换？

处理器从用户态切换到内核态的方法有三种：系统调用、异常和外部中断。

1.  系统调用是操作系统的最小功能单位，是操作系统提供的用户接口，系统调用本身是一种软中断。
2.  异常，也叫做内中断，是由错误引起的，如文件损坏、缺页故障等。
3.  外部中断，是通过两根信号线来通知处理器外设的状态变化，是硬中断。

## 并发和并行的区别

1.  并发（concurrency）：指宏观上看起来两个程序在同时运行，比如说在单核cpu上的多任务。但是从微观上看两个程序的指令是交织着运行的，指令之间交错执行，在单个周期内只运行了一个指令。这种并发并不能提高计算机的性能，只能提高效率（如降低某个进程的相应时间）。
2.  并行（parallelism）：指严格物理意义上的同时运行，比如多核cpu，两个程序分别运行在两个核上，两者之间互不影响，单个周期内每个程序都运行了自己的指令，也就是运行了两条指令。这样说来并行的确提高了计算机的效率。所以现在的cpu都是往多核方面发展。

## 进程

### 什么是进程？

进程是操作系统中最重要的抽象概念之一，是资源分配的基本单位，是独立运行的基本单位。

进程的经典定义就是一个执行中程序的实例。系统中的每个程序都运行在某个进程的上下文（context）中。

上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。

进程一般由以下的部分组成：

1.  进程控制块PCB，是进程存在的唯一标志，包含进程标识符PID，进程当前状态，程序和数据地址，进程优先级、CPU现场保护区（用于进程切换），占有的资源清单等。
2.  程序段
3.  数据段



### 简述进程间通信方法

每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区,进程A把数据从用户空间拷到内核缓冲区,进程B再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信。

不同进程间的通信本质：进程之间可以看到一份公共资源；而提供这份资源的形式或者提供者不同，造成了通信方式不同。

进程间通信主要包括管道、系统IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字socket。

### 进程如何通过管道进行通信

管道是一种最基本的IPC机制，作用于有血缘关系的进程之间，完成数据传递。调用pipe系统函数即可创建一个管道。有如下特质：

1.  其本质是一个伪文件(实为内核缓冲区)
2.  由两个文件描述符引用，一个表示读端，一个表示写端。
3.  规定数据从管道的写端流入管道，从读端流出。

管道的原理: 管道实为内核使用环形队列机制，借助内核缓冲区实现。

管道的局限性：

1.  数据自己读不能自己写。
2.  数据一旦被读走，便不在管道中存在，不可反复读取。
3.  由于管道采用半双工通信方式。因此，数据只能在一个方向上流动。
4.  只能在有公共祖先的进程间使用管道。



### 进程如何通过共享内存通信？

它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。

特点：

1.  共享内存是最快的一种IPC，因为进程是直接对内存进行操作来实现通信，避免了数据在用户空间和内核空间来回拷贝。
2.  因为多个进程可以同时操作，所以需要进行同步处理。
3.  信号量和共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。

### 什么是信号

一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。 Linux 系统上支持的30 种不同类型的信号。 每种信号类型都对应于某种系统事件。低层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户进程而言是不可见的。信号提供了一种机制，通知用户进程发生了这些异常。

1.  发送信号：内核通过更新目的进程上下文中的某个状态，发送（递送）一个信号给目的进程。发送信号可以有如下两种原因：
    -   内核检测到一个系统事件，比如除零错误或者子进程终止。
    -   —个进程调用了kill 函数， 显式地要求内核发送一个信号给目的进程。一个进程可以发送信号给它自己。
2.  接收信号：当目的进程被内核强迫以某种方式对信号的发送做出反应时，它就接收了信号。进程可以忽略这个信号，终止或者通过执行一个称为信号处理程序(signal handler)的用户层函数捕获这个信号。

### 如何编写正确且安全的信号处理函数

1.  处理程序要尽可能简单。 避免麻烦的最好方法是保持处理程序尽可能小和简单。例如，处理程序可能只是简单地设置全局标志并立即返回；所有与接收信号相关的处理都由主程序执行，它周期性地检查(并重置)这个标志。

2.  在处理程序中只调用异步信号安全的函数。 所谓异步信号安全的函数(或简称安全的函数)能够被信号处理程序安全地调用，原因有二：要么它是可重入的(例如只访问局部变量），要么它不能被信号处理程序中断。

3.  保存和恢复errno。 许多Linux 异步信号安全的函数都会在出错返回时设置errno在处理程序中调用这样的函数可能会干扰主程序中其他依赖于分。解决方法是在进人处理程序时把errno 保存在一个局部变量中，在处理程序返回前恢复它。注意，只有在处理程序要返回时才有此必要。如果处理程序调用_exit终止该进程，那么就不需要这样做了。

4.  阻塞所有的信号，保护对共享全局数据结构的访问。 如果处理程序和主程序或其他处理程序共享一个全局数据结构，那么在访问(读或者写)该数据结构时，你的处理程序和主程序应该暂时阻塞所有的信号。这条规则的原因是从主程序访问一个数据结构d 通常需要一系列的指令，如果指令序列被访问d 的处理程序中断，那么处理程序可能会发现d 的状态不一致，得到不可预知的结果。在访问d 时暂时阻塞信号保证了处理程序不会中断该指令序列。

5.  用volatile 声明全局变量。 考虑一个处理程序和一个main 函数，它们共享一个全局变量g 。处理程序更新g，main 周期性地读g， 对于一个优化编译器而言，main 中g的值看上去从来没有变化过，因此使用缓存在寄存器中g 的副本来满足对g 的每次引用是很安全的。如果这样，main 函数可能永远都无法看到处理程序更新过的值。可以用volatile 类型限定符来定义一个变量，告诉编译器不要缓存这个变量。例如：volatile 限定符强迫编译器毎次在代码中引用g时，都要从内存中读取g的值。一般来说，和其他所有共享数据结构一样，应该暂时阻塞信号，保护每次对全局变量的访问。

    ```c
    volatile int g;
    ```

6.  用sig*atomic*t声明标志。在常见的处理程序设计中，处理程序会写全局标志来记录收到了信号。主程序周期性地读这个标志，响应信号，再清除该标志。对于通过这种方式来共享的标志，C 提供一种整型数据类型sig*atomic*t对它的读和写保证会是原子的（不可中断的）。

7.  信号的一个与直觉不符的方面是未处理的信号是不排队的。因为 pending 位向量中每种类型的信号只对应有一位，所以每种类型最多只能有一个未处理的信号。关键思想是如果存在一个未处理的信号就表明至少有一个信号到达了。

### 进程调度的时机

1.  当前运行的进程运行结束。
2.  当前运行的进程由于某种原因阻塞。
3.  执行完系统调用等系统程序后返回用户进程。
4.  在使用抢占调度的系统中，具有更高优先级的进程就绪时。
5.  分时系统中，分给当前进程的时间片用完。

### 不能进行进程调度的情况

1.  在中断处理程序执行时。
2.  在操作系统的内核程序临界区内。
3.  其它需要完全屏蔽中断的原子操作过程中。

### 简述进程组

进程组即多个进程的集合,进程组有一个组长,组长进程的PID等于进程组的PGID。

### 进程调度算法

先来先服务调度算法：创建一个任务队列，一旦有新任务就加入这个队列，CPU完成一个任务后就从队列取任务。

短作业(进程)优先调度算法：针对较短的作业，优先调给CPU工作。

时间片轮转算法：每个时间片依次执行一个任务，时间片结束后将该任务放回任务队列。

多级反馈队列：也按时间片轮转算法执行任务，设置n个队列，当第一个队列任务为空，才执行第二个队列，依次类推。 如果在i队列的任务在该时间片执行后没有完成，即插入i+1号队列。

### 进程的调度策略

1.  先到先服务调度算法
2.  短作业优先调度算法
3.  优先级调度算法
4.  时间片轮转调度算法
5.  高响应比优先调度算法
6.  多级队列调度算法
7.  多级反馈队列调度算法

### 进程调度策略的基本设计指标

1.  CPU利用率
2.  系统吞吐率，即单位时间内CPU完成的作业的数量。
3.  响应时间。
4.  周转时间。是指作业从提交到完成的时间间隔。从每个作业的角度看，完成每个作业的时间也是很关键
    -   平均周转时间
    -   带权周转时间
    -   平均带权周转时间

### 进程的状态与状态转换

进程在运行时有三种基本状态：就绪态、运行态和阻塞态。

1.运行（running）态：进程占有处理器正在运行的状态。进程已获得CPU，其程序正在执行。在单处理机系统中，只有一个进程处于执行状态； 在多处理机系统中，则有多个进程处于执行状态。

2.就绪（ready）态：进程具备运行条件，等待系统分配处理器以便运行的状态。 当进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可立即执行，进程这时的状态称为就绪状态。在一个系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。

3.阻塞（wait）态：又称等待态或睡眠态，指进程不具备运行条件，正在等待某个时间完成的状态。

各状态之间的转换：

1.  就绪→执行 处于就绪状态的进程，当进程调度程序为之分配了处理机后，该进程便由就绪状态转变成执行状态。
2.  执行→就绪 处于执行状态的进程在其执行过程中，因分配给它的一个时间片已用完而不得不让出处理机，于是进程从执行状态转变成就绪状态。
3.  执行→阻塞 正在执行的进程因等待某种事件发生而无法继续执行时，便从执行状态变成阻塞状态。
4.  阻塞→就绪 处于阻塞状态的进程，若其等待的事件已经发生，于是进程由阻塞状态转变为就绪状态。

### 什么是孤儿进程？僵尸进程?

1.  孤儿进程： 父进程退出，子进程还在运行的这些子进程都是孤儿进程，孤儿进程将被init进程（1号进程）所收养，并由init进程对他们完成状态收集工作。
2.   僵尸进程： 进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait 获waitpid 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中的这些进程是僵尸进程。



### 进程同步的方法

操作系统中，进程是具有不同的地址空间的，两个进程是不能感知到对方的存在的。有时候，需要多个进程来协同完成一些任务。 当多个进程需要对同一个内核资源进行操作时，这些进程便是竞争的关系，操作系统必须协调各个进程对资源的占用，进程的互斥是解决进程间竞争关系的方法。 进程互斥指若干个进程要使用同一共享资源时，任何时刻最多允许一个进程去使用，其他要使用该资源的进程必须等待，直到占有资源的进程释放该资源。 当多个进程协同完成一些任务时，不同进程的执行进度不一致，这便产生了进程的同步问题。需要操作系统干预，在特定的同步点对所有进程进行同步，这种协作进程之间相互等待对方消息或信号的协调关系称为进程同步。进程互斥本质上也是一种进程同步。 进程的同步方法：

1.  互斥锁
2.  读写锁
3.  条件变量
4.  记录锁(record locking)
5.  信号量
6.  屏障（barrier）

### 进程同步与线程同步有什么区别

进程之间地址空间不同，不能感知对方的存在，同步时需要将锁放在多进程共享的空间。而线程之间共享同一地址空间，同步时把锁放在所属的同一进程空间即可。

## 线程

### 什么是线程？

1.  是进程划分的任务，是一个进程内可调度的实体，是CPU调度的基本单位，用于保证程序的实时性，实现进程内部的并发。
2.  线程是操作系统可识别的最小执行和调度单位。每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。
3.  每个线程完成不同的任务，但是属于同一个进程的不同线程之间共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。

### 简述协程

协程，即用户态线程。我们知道，在Linux下，线程有PCB，然后可以占用时间片去调度，但是在用户态线程中，该线程的执行不由内核做调度，由用户自己实现

可以这么理解，在用户进程A中，再实现了个调度器，调度用户线程，这些线程不像之前的线程，内核是感知不到的，它们只能感知到A的存在，用户态线程之间时间片只能争取内核分给进程A的时间片。

### 为什么需要线程？

线程产生的原因：进程可以使多个程序能并发执行，以提高资源的利用率和系统的吞吐量；但是其具有一些缺点：

1.  进程在同一时刻只能做一个任务，很多时候不能充分利用CPU资源。
2.  进程在执行的过程中如果发生阻塞，整个进程就会挂起，即使进程中其它任务不依赖于等待的资源，进程仍会被阻塞。

引入线程就是为了解决以上进程的不足，线程具有以下的优点：

1.  从资源上来讲，开辟一个线程所需要的资源要远小于一个进程。
2.  从切换效率上来讲，运行于一个进程中的多个线程，它们之间使用相同的地址空间，而且线程间彼此切换所需时间也远远小于进程间切换所需要的时间（这种时间的差异主要由于缓存的大量未命中导致）。
3.  从通信机制上来讲，线程间方便的通信机制。对不同进程来说，它们具有独立的地址空间，要进行数据的传递只能通过进程间通信的方式进行。线程则不然，属于同一个进程的不同线程之间共享同一地址空间，所以一个线程的数据可以被其它线程感知，线程间可以直接读写进程数据段（如全局变量）来进行通信（需要一些同步措施）。

### 简述线程和进程的区别和联系

1.  一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。
2.  进程在执行过程中拥有独立的地址空间，而多个线程共享进程的地址空间。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）
3.  进程是资源分配的最小单位，线程是CPU调度的最小单位。
4.  通信：由于同一进程中的多个线程具有相同的地址空间，使它们之间的同步和通信的实现，也变得比较容易。进程间通信`IPC`，线程间可以直接读写进程数据段（如全局变量）来进行通信（需要一些同步方法，以保证数据的一致性）。
5.  进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。
6.  进程间不会相互影响；一个进程内某个线程挂掉将导致整个进程挂掉。
7.  进程适应于多核、多机分布；线程适用于多核。

### 多线程模型

1.  多对一模型。将多个用户级线程映射到一个内核级线程上。该模型下，线程在用户空间进行管理，效率较高。缺点就是一个线程阻塞，整个进程内的所有线程都会阻塞。几乎没有系统继续使用这个模型。
2.  一对一模型。将内核线程与用户线程一一对应。优点是一个线程阻塞时，不会影响到其它线程的执行。该模型具有更好的并发性。缺点是内核线程数量一般有上限，会限制用户线程的数量。更多的内核线程数目也给线程切换带来额外的负担。linux和Windows操作系统家族都是使用一对一模型。
3.  多对多模型。将多个用户级线程映射到多个内核级线程上。结合了多对一模型和一对一模型的特点。

## 死锁是怎样产生的？

死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象。 产生死锁需要满足下面四个条件：

1.  互斥条件：进程对所分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源。
2.  占有并等待条件：进程获得一定的资源后，又对其他资源发出请求，但是该资源可能被其他进程占有，此时请求阻塞，但该进程不会释放自己已经占有的资源。
3.  非抢占条件：进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用后自己释放。
4.  循环等待条件：进程发生死锁后，必然存在一个进程-资源之间的环形链。

## 如何解决死锁问题？

解决死锁的方法即破坏产生死锁的四个必要条件之一，主要方法如下:

1.  资源一次性分配，这样就不会再有请求了（破坏请求条件）。
2.  只要有一个资源得不到分配，也不给这个进程分配其他的资源（破坏占有并等待条件）。
3.  可抢占资源：即当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可抢占的条件。
4.  资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，释放则相反，从而破坏环路等待的条件

## 什么是虚拟地址，什么是物理地址？

地址空间是一个非负整数地址的有序集合。

在一个带虚拟内存的系统中，CPU 从一个有N=pow(2,n)个地址的地址空间中生成虚拟地址，这个地址空间称为虚拟地址空间（virtual address space）,现代系统通常支持 32 位或者 64 位虚拟地址空间。

一个系统还有一个物理地址空间（physical address space），对应于系统中物理内存的M 个字节。

地址空间的概念是很重要的，因为它清楚地区分了数据对象（字节）和它们的属性（地址）。

一旦认识到了这种区别，那么我们就可以将其推广，允许每个数据对象有多个独立的地址，其中每个地址都选自一个不同的地址空间。这就是虚拟内存的基本思想。

主存中的每字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。



## 简述虚拟地址到物理地址转化过程

虚拟地址由虚拟页号和页偏移两部分组成。 通过虚拟地址的页面号，首先在快表中查询是否有该映射，查询不成功，在页表中找到该页对应的物理地址。 然后通过页物理地址+页偏移，得到真实的物理地址

## 简述页表

页表用于存储虚拟地址中的虚拟页面号和物理页面号的映射关系。 除此之外，有些页的读写有限制，页表也通过其他存储位，标记该页访问位，是否在内存中（可能被页面置换出去了）等等。

## 简述多级页表

多级页表用于减少内存的占用。以二级页表为例，虚拟地址被分为DIR,PAGE和offset三部分，通过顶级页表和DIR，寻找到该二级页表的起始位置，再通过二级页表的起始位置和PAGE，找到页物理地址，最后加上页偏移，即可得到最终的物理地址。

## 简述快表

快表也称为页表高速缓存。其会存储一定数量的页表项，以此加快虚拟地址到物理地址的映射速度。

## 简述MMU

MMU即内存管理单元，该硬件负责处理虚拟地址到物理地址的转化工作。快表也存储在MMU上。

## 什么是虚拟内存？

为了更加有效地管理内存并且少出错，现代系统提供了一种对主存的抽象概念，叫做虚拟内存(VM)。虚拟内存是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的、一致的和私有的地址空间。通过一个很清晰的机制，虚拟内存提供了三个重要的能力：

1.  它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。
2.  它为每个进程提供了一致的地址空间，从而简化了内存管理。
3.  它保护了每个进程的地址空间不被其他进程破坏。

## 为什么要引入虚拟内存？

1.  虚拟内存作为缓存的工具
    -   虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。
    -   虚拟内存利用DRAM缓存来自通常更大的虚拟地址空间的页面。
2.  虚拟内存作为内存管理的工具。操作系统为每个进程提供了一个独立的页表，也就是独立的虚拟地址空间。多个虚拟页面可以映射到同一个物理页面上。
    -   **简化链接：** 独立的地址空间允许每个进程的内存映像使用相同的基本格式，而不管代码和数据实际存放在物理内存的何处。
    -   例如：一个给定的`linux`系统上的每个进程都是用类似的内存格式，对于64为地址空间，代码段总是从虚拟地址）`0x400000`开始，数据段，代码段，栈，堆等等。
    -   **简化加载：** 虚拟内存还使得容易向内存中加载可执行文件和共享对象文件。要把目标文件中.text和.data节加载到一个新创建的进程中，Linux加载器为代码和数据段分配虚拟页VP，把他们**标记为无效（未被缓存）** ，将页表条目指向目标文件的起始位置。
    -   **加载器从不在磁盘到内存实际复制任何数据，在每个页初次被引用时，虚拟内存系统会按照需要自动的调入数据页。**
    -   **简化共享：** 独立地址空间为OS提供了一个管理用户进程和操作系统自身之间共享的一致机制。
        -   一般：每个进程有各自私有的代码，数据，堆栈，是不和其他进程共享的，**这样OS创建页表，将虚拟页映射到不连续的物理页面。**
        -   某些情况下，需要进程来共享代码和数据。例如每个进程调用相同的操作系统内核代码，或者C标准库函数。**OS会把不同进程中适当的虚拟页面映射到相同的物理页面。**
    -   **简化内存分配：** 虚拟内存向用户提供一个简单的分配额外内存的机制。当一个运行在用户进程中的程序要求额外的堆空间时（如`malloc`），OS分配一个适当k大小个连续的虚拟内存页面，并且将他们映射到物理内存中任意位置的k个任意物理页面，**因此操作系统没有必要分配k个连续的物理内存页面，页面可以随机的分散在物理内存中**。

-   虚拟内存作为内存保护的工具。不应该允许一个用户进程修改它的只读段，也不允许它修改任何内核代码和数据结构，不允许读写其他进程的私有内存，不允许修改任何与其他进程共享的虚拟页面。每次CPU生成一个地址时，`MMU`会读一个`PTE`，通过在`PTE`上添加一些额外的许可位来控制对一个虚拟页面内容的访问十分简单。

## 常见的页面置换算法

当访问一个内存中不存在的页，并且内存已满，则需要从内存中调出一个页或将数据送至磁盘对换区，替换一个页，这种现象叫做缺页置换。当前操作系统最常采用的缺页置换算法如下：

-   先进先出(FIFO)算法：
-   思路：置换最先调入内存的页面，即置换在内存中驻留时间最久的页面。
-   实现：按照进入内存的先后次序排列成队列，从队尾进入，从队首删除。
-   特点：实现简单；性能较差，调出的页面可能是经常访问的
-   最近最少使用（`LRU`）算法:
-   思路： 置换最近一段时间以来最长时间未访问过的页面。根据程序局部性原理，刚被访问的页面，可能马上又要被访问；而较长时间内没有被访问的页面，可能最近不会被访问。
-   实现：缺页时，计算内存中每个逻辑页面的上一次访问时间，选择上一次使用到当前时间最长的页面
-   特点：可能达到最优的效果，维护这样的访问链表开销比较大

当前最常采用的就是`LRU`算法。

-   最不常用算法（`Least Frequently Used, LFU`）
-   思路：缺页时，置换访问次数最少的页面
-   实现：每个页面设置一个访问计数，访问页面时，访问计数加1，缺页时，置换计数最小的页面
-   特点：算法开销大，开始时频繁使用，但以后不使用的页面很难置换

## 请说一下什么是写时复制？

-   如果有多个进程要读取它们自己的那部门资源的副本，那么复制是不必要的。每个进程只要保存一个指向这个资源的指针就可以了。只要没有进程要去修改自己的“副本”，就存在着这样的幻觉：每个进程好像独占那个资源。从而就避免了复制带来的负担。如果一个进程要修改自己的那份资源“副本”，那么就会复制那份资源，并把复制的那份提供给进程。不过其中的复制对进程来说是透明的。这个进程就可以修改复制后的资源了，同时其他的进程仍然共享那份没有修改过的资源。所以这就是名称的由来：在写入时进行复制。
-   写时复制的主要好处在于：如果进程从来就不需要修改资源，则不需要进行复制。惰性算法的好处就在于它们尽量推迟代价高昂的操作，直到必要的时刻才会去执行。
-   在使用虚拟内存的情况下，写时复制（Copy-On-Write）是以页为基础进行的。所以，只要进程不修改它全部的地址空间，那么就不必复制整个地址空间。在fork()调用结束后，父进程和子进程都相信它们有一个自己的地址空间，但实际上它们共享父进程的原始页，接下来这些页又可以被其他的父进程或子进程共享。

## 优先级反转是什么？如何解决

由于多进程共享资源，具有最高优先权的进程被低优先级进程阻塞，反而使具有中优先级的进程先于高优先级的进程执行，导致系统的崩溃。这就是所谓的优先级反转(Priority Inversion)。其实,优先级反转是在高优级(假设为A)的任务要访问一个被低优先级任务(假设为C)占有的资源时,被阻塞.而此时又有优先级高于占有资源的任务(C)而低于被阻塞的任务(A)的优先级的任务(假设为B)时,于是,占有资源的任务就被挂起(占有的资源仍为它占有),因为占有资源的任务优先级很低,所以,它可能一直被另外的任务挂起.而它占有的资源也就一直不能释放,这样,引起任务A一直没办法执行.而比它优先低的任务却可以执行。

目前解决优先级反转有许多种方法。其中普遍使用的有2种方法：一种被称作优先级继承(priority inheritance)；另一种被称作优先级极限(priority ceilings)。

1.  优先级继承(priority inheritance) 优先级继承是指将低优先级任务的优先级提升到等待它所占有的资源的最高优先级任务的优先级.当高优先级任务由于等待资源而被阻塞时,此时资源的拥有者的优先级将会自动被提升。
2.  优先级天花板(priority ceilings)优先级天花板是指将申请某资源的任务的优先级提升到可能访问该资源的所有任务中最高优先级任务的优先级.(这个优先级称为该资源的优先级天花板)。

## 简述 select

select是一种多路复用技术。其收到所有输入的文件描述符，返回哪些文件有新数据。

其可以设置为阻塞或者非阻塞状态，底层采用1024位bitmap做实现，因此有文件描述符上限数

## 简述poll

poll是一种多路复用技术。其收到所有输入的文件描述符，返回哪些文件有新数据。

其通过链表代替了之前select的数据结构，使得其没有上限限制。

## 简述epoll

poll是一种多路复用技术。其采用一个文件描述符管理多个输入的文件描述符，采用事件回调的方式，提高了程序运行效率。

# 数据库

## 简述数据库三大范式

第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。

数据库第二范式：关系模式必须满足第一范式，并且所有非主属性都完全依赖于主码。注意，符合第二范式的关系模型可能还存在数据冗余、更新异常等问题。关系模型（学号，姓名，专业编号，专业名称）中，学号->姓名，而专业编号->专业名称，不满足数据库第二范式

数据库第三范式：关系模型满足第二范式，所有非主属性对任何候选关键字都不存在传递依赖。即每个属性都跟主键有直接关系而不是间接关系。接着以学生表举例，对于关系模型（学号，姓名，年龄，性别，所在院校，院校地址，院校电话）院校地址，院校电话和学号不存在直接关系，因此不满足第三范式。

## 锁

### 简述MySQL的共享锁排它锁

共享锁也称为读锁，相互不阻塞，多个客户在同一时刻可以同时读取同一个资源而不相互干扰。排他锁也称为写锁，会阻塞其他的写锁和读锁，确保在给定时间内只有一个用户能执行写入并防止其他用户读取正在写入的同一资源。

### 如何解决数据库死锁

1.  预先检测到死锁的循环依赖，并立即返回一个错误。
2.  当查询的时间达到锁等待超时的设定后放弃锁请求。

### 简述乐观锁和悲观锁

乐观锁：对于数据冲突保持一种乐观态度，操作数据时不会对操作的数据进行加锁，只有到数据提交的时候才通过一种机制来验证数据是否存在冲突。

悲观锁：对于数据冲突保持一种悲观态度，在修改数据之前把数据锁住，然后再对数据进行读写，在它释放锁之前任何人都不能对其数据进行操作，直到前面一个人把锁释放后下一个人数据加锁才可对数据进行加锁，然后才可以对数据进行操作，一般数据库本身锁的机制都是基于悲观锁的机制实现的。

### 简述MySQL中的按粒度的锁分类

表级锁: 对当前操作的整张表加锁,实现简单，加锁快，但并发能力低。

行锁: 锁住某一行，如果表存在索引，那么记录锁是锁在索引上的，如果表没有索引，那么 InnoDB 会创建一个隐藏的聚簇索引加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。

Gap 锁：也称为间隙锁: 锁定一个范围但不包括记录本身。其目的是为了防止同一事物的两次当前读出现幻读的情况。

Next-key Lock： 行锁+gap锁。

## 引擎

### 简述InnoDB存储引擎

InnoDB 是 MySQL 的默认事务型引擎，支持事务，表是基于聚簇索引建立的。支持表级锁和行级锁，支持外键，适合数据增删改查都频繁的情况。

InnoDB 采用 MVCC 来支持高并发，并且实现了四个标准的隔离级别。其默认级别是 REPEATABLE READ，并通过间隙锁策略防止幻读，间隙锁使 InnoDB 不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定防止幻行的插入。

### 简述MyISAM存储引擎

MySQL5.1及之前，MyISAM 是默认存储引擎。MyISAM不支持事务，Myisam支持表级锁，不支持行级锁，表不支持外键，该存储引擎存有表的行数，count运算会更快。适合查询频繁，不适合对于增删改要求高的情况

### 简述Memory存储引擎

Memory存储引擎将所有数据都保存在内存，不需要磁盘 IO。支持哈希索引，因此查找速度极快。Memory 表使用表级锁，因此并发写入的性能较低。

## mysql

### 简述MySQL的架构

MySQL可以分为应用层,逻辑层,数据库引擎层,物理层。

应用层：负责和客户端，响应客户端请求，建立连接，返回数据。

逻辑层：包括SQK接口，解析器，优化器，Cache与buffer。

数据库引擎层：有常见的MyISAM,InnoDB等等。

物理层：负责文件存储，日志等等。

### 简述MySQL使用EXPLAIN 的关键字段

explain关键字用于分析sql语句的执行情况，可以通过他进行sql语句的性能分析。

type：表示连接类型，从好到差的类型排序为

-   system：系统表，数据已经加载到内存里。
-   const：常量连接，通过索引一次就找到。
-   eq_ref：唯一性索引扫描，返回所有匹配某个单独值的行。
-   ref：非主键非唯一索引等值扫描，const或eq_ref改为普通非唯一索引。
-   range：范围扫描，在索引上扫码特定范围内的值。
-   index：索引树扫描，扫描索引上的全部数据。
-   all：全表扫描。

key：显示MySQL实际决定使用的键。

key_len：显示MySQL决定使用的键长度，长度越短越好

Extra：额外信息

-   Using filesort：MySQL使用外部的索引排序，很慢需要优化。
-   Using temporary：使用了临时表保存中间结果，很慢需要优化。
-   Using index：使用了覆盖索引。
-   Using where：使用了where。

### 简述执行SQL语言的过程

1.  客户端首先通过连接器进行身份认证和权限相关
2.  如果是执行查询语句的时候，会先查询缓存，但MySQL 8.0 版本后该步骤移除。
3.  没有命中缓存的话，SQL 语句就会经过解析器，分析语句，包括语法检查等等。
4.  通过优化器，将用户的SQL语句按照 MySQL 认为最优的方案去执行。
5.  执行语句，并从存储引擎返回数据。

### 简述MySQL优化流程

1.  通过慢日志定位执行较慢的SQL语句
2.  利用explain对这些关键字段进行分析
3.  根据分析结果进行优化


### 简述MySQL中的日志log

redo log: 存储引擎级别的log（InnoDB有，MyISAM没有），该log关注于事务的恢复.在重启mysql服务的时候，根据redo log进行重做，从而使事务有持久性。

undo log：是存储引擎级别的log（InnoDB有，MyISAM没有）保证数据的原子性，该log保存了事务发生之前的数据的一个版本，可以用于回滚，是MVCC的重要实现方法之一。

bin log：数据库级别的log，关注恢复数据库的数据。

### MySQL是如何保证主备一致的？

MySQL通过binlog（二进制日志）实现主备一致。binlog记录了所有修改了数据库或可能修改数据库的语句，而不会记录select、show这种不会修改数据库的语句。在备份的过程中，主库A会有一个专门的线程将主库A的binlog发送给 备库B进行备份。其中binlog有三种记录格式：

1.  statement:记录对数据库进行修改的语句本身，有可能会记录一些额外的相关信息。优点是binlog日志量少，IO压力小，性能较高。缺点是由于记录的信息相对较少，在不同库执行时由于上下文的环境不同可能导致主备不一致。
2.  row:记录对数据库做出修改的语句所影响到的数据行以及对这些行的修改。比如当修改涉及多行数据，会把涉及的每行数据都记录到binlog。优点是能够完全的还原或者复制日志被记录时的操作。缺点是日志量占用空间较大，IO压力大，性能消耗较大。
3.  mixed:混合使用上述两种模式，一般的语句使用statment方式进行保存，如果遇到一些特殊的函数，则使用row模式进行记录。MySQL自己会判断这条SQL语句是否可能引起主备不一致，如果有可能，就用row格式， 否则就用statement格式。但是在生产环境中，一般会使用row模式。

### redo log与binlog的区别？

1.  redo log是InnoDB引擎特有的，只记录该引擎中表的修改记录。binlog是MySQL的Server层实现的，会记录所有引擎对数据库的修改。
2.  redo log是物理日志，记录的是在具体某个数据页上做了什么修改；binlog是逻辑日志，记录的是这个语句的原始逻辑。
3.  redo log是循环写的，空间固定会用完；binlog是可以追加写入的，binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。

### crash-safe能力是什么？

InnoDB通过redo log保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe。

### WAL技术是什么？

WAL的全称是Write-Ahead Logging，它的关键点就是先写日志，再写磁盘。事务在提交写入磁盘前，会先写到redo log里面去。如果直接写入磁盘涉及磁盘的随机I/O访问，涉及磁盘随机I/O访问是非常消耗时间的一个过程，相比之下先写入redo log，后面再找合适的时机批量刷盘能提升性能。

### 两阶段提交是什么？

为了保证binlog和redo log两份日志的逻辑一致，最终保证恢复到主备数据库的数据是一致的，采用两阶段提交的机制。

1.  执行器调用存储引擎接口，存储引擎将修改更新到内存中后，将修改操作记录redo log中，此时redo log处于prepare状态。
2.  存储引擎告知执行器执行完毕，执行器生成这个操作对应的binlog，并把binlog写入磁盘。
3.  执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交commit状态，更新完成。

### 只靠binlog可以支持数据库崩溃恢复吗？

不可以。 历史原因：

1.  InnoDB在作为MySQL的插件加入MySQL引擎家族之前，就已经是一个提供了崩溃恢复和事务支持的引擎了。InnoDB接入了MySQL后，发现既然binlog没有崩溃恢复的能力，那引入InnoDB原有的redo log来保证崩溃恢复能力。 实现原因：
2.  binlog没有记录数据页修改的详细信息，不具备恢复数据页的能力。binlog记录着数据行的增删改，但是不记录事务对数据页的改动，这样细致的改动只记录在redo log中。当一个事务做增删改时，其实涉及到的数据页改动非常细致和复杂，包括行的字段改动以及行头部以及数据页头部的改动，甚至b+tree会因为插入一行而发生若干次页面分裂，那么事务也会把所有这些改动记录下来到redo log中。因为数据库系统进程crash时刻，磁盘上面页面镜像可以非常混乱，其中有些页面含有一些正在运行着的事务的改动，而一些已提交的事务的改动并没有刷上磁盘。事务恢复过程可以理解为是要把没有提交的事务的页面改动都去掉，并把已经提交的事务的页面改动都加上去这样一个过程。这些信息，都是binlog中没有记录的，只记录在了存储引擎的redo log中。
3.  操作写入binlog可细分为write和fsync两个过程，write指的就是指把日志写入到文件系统的page cache，并没有把数据持久化到磁盘,fsync才是将数据持久化到磁盘的操作。通过参数设置sync_binlog为0的时候，表示每次提交事务都只write，不fsync。此时数据库崩溃可能导致部分提交的事务以及binlog日志由于没有持久化而丢失。

### 简述MySQL主从复制

MySQL提供主从复制功能，可以方便的实现数据的多处自动备份，不仅能增加数据库的安全性，还能进行读写分离，提升数据库负载性能。

主从复制流程：

1.  在事务完成之前，主库在binlog上记录这些改变，完成binlog写入过程后，主库通知存储引擎提交事物
2.  从库将主库的binlog复制到对应的中继日志，即开辟一个I/O工作线程，I/O线程在主库上打开一个普通的连接，然后开始binlog dump process，将这些事件写入中继日志。从主库的binlog中读取事件，如果已经读到最新了，线程进入睡眠并等待ma主库产生新的事件。

读写分离：即只在MySQL主库上写，只在MySQL从库上读，以减少数据库压力，提高性能。

### MySQL数据存储过程

一般来说，普通的SQL语句需要先编译然后执行，而存储过程可以理解为为了完成特定功能的已经编译后的SQL语句集。用户可通过存储过程的名字并给定参数来调用

### MySQL数据库触发器

触发器简单来说就是监视某种情况，并触发某种操作。 当触发器所在表上出现指定事件(insert/update/delete)时，可指定时间(after/before)执行特定事件(insert/update/delete)

### SQL优化方法

核心就是避免全表扫描，多走索引。列举常用的一些优化方法：

1.  尽量对利用字段较多的建立索引，即在 where 及 order by 涉及的列上建立索引。
2.  尽量避免在 where 子句中使用 or ，null值判断，in 和对字段进行表达式操作
3.  建立索引时需要多考虑最左匹配原则

### mysql的操作 增删改查

增：INSERT INTO 表名（字段名1，字段名2，…）VALUES（值1，值2，…）

删：DELETE FROM 表名 [WHERE 条件表达式] TRUNCTE [TABLE ] 表名（删除整张表数据）

改：UPDATE 表名 SET 字段名1=值1，[ ，字段名2=值2，…] [ WHERE 条件表达式 ]

查：SELECT 字段名1，字段名2，… FROM 表名 [ WHERE 条件表达式 ]

### mysql的查询语法顺序

where、group by、having、order by、limit

### delete和truncate区别

delete是数据操纵语言（DML），其按行删除，支持where语句，执行操作采用行锁，执行操作时会将该操作记录在redo和undo中，因此支持回滚。

truncate是数据定义语言（DDL），其操作隐式提交，不支持回滚，不支持where，删除时采用表级锁进行删除。

### 什么情况下分表合适

针对存储了百万级乃至千万级条记录的大表。数据库在查询和插入的时候耗时太长，可通过分表，将大表拆分成小表，提升数据库性能。

### 关系型数据库与非关系型数据库区别

关系型数据库采用了关系模型（可以简单理解为二维表格类型）组织数据，一般可以遵守事务的ACID特性 不是由关系模型进行存储的均可视作非关系型数据库，比如以键值对的redis，图数据库等。

### 乐观锁如何保证一致性

乐观锁保持一致性主要通过两个方法。

1.  通过数据属性中，增加版本号属性，进行比较，比较目前操作数据是否是最新版本。
2.  CAS（compare and swap）即在对数据修改过程中，采用CAS算法，保证在并发下的一致性。

### mysql为什么要用自增id作为主键

直接原因是其存储机制。MySQL采用数据页进行数据存储。 如果采用自增主键，在原先数据页写满的情况下，MySQL对于新数据，直接开辟新页进行写操作。 如果不采用自增主键，为保障索引有序，新数据需插入到合适位置上，由此针对页数据满的情况下，MySQL需要申请新页，并将一部分之前的页数据挪到新页上，保证按索引有序存储，相对自增主键IO开销更大。

### 大数据量的分页查询怎么优化

定位对应索引id所处的偏移位置，之后进行查询。

```
select * from table where num = 8 limit 100000,1;
```

变为

```
select * from table where num = 8 and id >= (
    select id from table where num = 8 limit 100000,1
) limit 100;
```

由于id走了索引，因此速度会有一定提升。

### 分库分表怎么做

对于分库，即将一个数据库拆分为多个库。 可以通过水平拆分，或者垂直拆分的方式，将表进行拆分。 一般可以采用中间件Sharding-JDBC进行分库分表。

### char和varchar区别

CHAR的长度是不可变的，而VARCHAR的长度是可变的。 因此CHAR效率高，VARCHAR效率偏低

### Mysql varchar字段怎么存储

varchar字段开头包含一个变长字段的实际长度，后面存储的是真实字符

## 事务

### 简述事务

事务内的语句要么全部执行成功，要么全部执行失败。

事务满足如下几个特性：		

>   -   原子性（Atomicity）:一个事务中的所有操作要么全部完成，要么全部不完成。
>   -   一致性（Consistency）: 事务执行前后数据库的状态保存一致。
>   -   隔离性（Isolation） 多个并发事务对数据库进行操作，事务间互不干扰。
>   -   持久性（Durability） 事务执行完毕，对数据的修改是永久的，即使系统故障也不会丢失

### InnoDB如何保证事务的原子性、持久性和一致性？

利用undo log保障原子性。该log保存了事务发生之前的数据的一个版本，可以用于回滚，从而保证事务原子性。

利用redo log保证事务的持久性，该log关注于事务的恢复.在重启mysql服务的时候，根据redo log进行重做，从而使事务有持久性。

利用undo log+redo log保障一致性。事务中的执行需要redo log，如果执行失败，需要undo log 回滚。

1.  

### SQL的事务隔离级别有哪些？

>   -   读未提交：一个事务还没提交，它做的变更就能被别的事务看到。
>   -   读已提交： 一个事务提交后，它做的变更才能被别的事务看到。
>   -   可重复读： 一个事务执行过程中看到的数据总是和事务启动时看到的数据是一致的。在这个级别下事务未提交，做出的变更其它事务也看不到。
>   -   串行化： 对于同一行记录进行读写会分别加读写锁，当发生读写锁冲突，后面执行的事务需等前面执行的事务完成才能继续执行。

### 数据库中多个事务同时进行可能会出现什么问题？

-   丢失修改
-   脏读：当前事务可以查看到别的事务未提交的数据。
-   不可重读：在同一事务中，使用相同的查询语句，同一数据资源莫名改变了。
-   幻读：在同一事务中，使用相同的查询语句，莫名多出了一些之前不存在的数据，或莫名少了一些原先存在的数据。

### 脏读是什么，如何解决

一个事务读取了另一个事务修改但未提交的数据

将事务隔离级别设置为：读已提交，串行化，可重复读进行解决。

### 不可重复读是什么，如何解决

一个事务连续读两次数据，但结果不一样。(两次读之间，数据被其他事务修改)。

将事务隔离级别设置为：串行化，可重复读进行解决。

### 幻读是什么，如何解决

一个事务连续读两次数据，读取数据量不一样。(两次读之前，数据被其他事务删除或新增)。

将事务隔离级别设置为：串行化，或在innodb引擎中有gap锁的情况下设置可重复读进行解决。

### 丢失修改是什么

数据被两个事务连续修改，导致第一个事务的修改被第二个事务覆盖丢失。

### 什么是MVCC？

MVCC为多版本并发控制，即同一条记录在系统中存在多个版本。其存在目的是在保证数据一致性的前提下提供一种高并发的访问性能。对数据读写在不加读写锁的情况下实现互不干扰,从而实现数据库的隔离性,在事务隔离级别为读提交和可重复读中使用到。

在InnoDB中，事务在开始前会向事务系统申请一个事务ID，该ID是按申请顺序严格递增的。每行数据具有多个版本，每次事务更新数据都会生成新的数据版本，而不会直接覆盖旧的数据版本。数据的行结构中包含多个信息字段。其中实现MVCC的主要涉及最近更改该行数据的事务ID（DB*TRX*ID）和可以找到历史数据版本的指针（DB*ROLL*PTR）。InnoDB在每个事务开启瞬间会为其构造一个记录当前已经开启但未提交的事务ID的视图数组。通过比较链表中的事务ID与该行数据的值与对应的DB*TRX*ID，并通过DB*ROLL*PTR找到历史数据的值以及对应的DB*TRX*ID来决定当前版本的数据是否应该被当前事务所见。最终实现在不加锁的情况下保证数据的一致性。

### 读提交和可重复读都基于MVCC实现，有什么区别？

在可重复读级别下，只会在事务开始前创建视图，事务中后续的查询共用一个视图。而读提交级别下每个语句执行前都会创建新的视图。因此对于可重复读，查询只能看到事务创建前就已经提交的数据。而对于读提交，查询能看到每个语句启动前已经提交的数据。



## 索引

### 索引是什么？

索引是存储引擎中用于快速找到记录的一种数据结构。在关系型数据库中，索引具体是一种对数据库中一列或多列的值进行排序的存储结构

### 为什么引入索引？

为了提高数据查询的效率。索引对数据库查询良好的性能非常关键，当表中数据量越来越大，索引对性能的影响越重要。

### 什么时候需要创建索引

1.  需要频繁被作为查询条件的字段
2.  查询过程中排序的字段创建索引
3.  查询过程中统计或者分组的字段

### 简述联合索引和最左匹配原则

联合索引是指对表上的多个列的关键词进行索引。

对于联合索引的查询，如果精确匹配联合索引的左边连续一列或者多列，则mysql会一直向右匹配直到遇到范围查询（>,<,between,like）就停止匹配。Mysql会对第一个索引字段数据进行排序，在第一个字段基础上，再对第二个字段排序。

### 何时索引会失效

1.  复合索引不满足最左匹配原则
2.  查询条件有or
3.  where 查询语句对索引列有数学运算或函数

### 简述主键索引和唯一索引

主键是能够唯一标识表中某一行的属性或属性组。对于表创建时未指定唯一索引的情况下，数据库会自动生成某一隐藏字段，作为唯一索引。

唯一索引是在表上一个或者多个字段组合建立的索引。

### Mysql有哪些常见索引类型？

-   数据结构角度

>   B-Tree索引 
>
>   哈希索引 
>
>   R-Tree索引 
>
>   全文索引

-   物理存储角度

>   主键索引（聚簇索引）：叶子节点存的是整行的数据 
>
>   非主键索引（二级索引）：叶子节点存的主键的值

### 简述Hash索引

哈希索引对于每一行数据计算一个哈希码，并将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。只有 Memory 引擎显式支持哈希索引。

Hash索引不支持范围查询，无法用于排序，也不支持部分索引列匹配查找。

### 简述自适应Hash索引

InnoDB对于频繁使用的某些索引值，会在内存中基于 B-Tree 索引之上再创键一个哈希索引，这也被称为自适应Hash索引。

### 简述聚集索引和稀疏索引

聚集索引按每张表的 主键构建一棵B+树，数据库中的每个搜索键值都有一个索引记录，每个数据页通过双向链表连接。表数据访问更快，但表更新代价高。

稀疏索引不会为每个搜索关键字创建索引记录。搜索过程需要，我们首先按索引记录进行操作，并按顺序搜索，直到找到所需的数据为止

### 简述辅助索引与回表查询

辅助索引是非聚集索引，叶子节点不包含记录的全部数据，包含了一个书签用来告诉InnoDB哪里可以找到与索引相对应的行数据。

通过辅助索引查询，先通过书签查到聚集索引，再根据聚集索引查对应的值，需要两次，也称为回表查询。

1.  

### 简述覆盖索引

覆盖索引指一个索引包含或覆盖了所有需要查询的字段的值，不需要回表查询，即索引本身存了对应的值。

### 基于主键索引的查询和非主键索引的查询有什么区别？

对于select * from 主键=XX，基于主键的普通查询仅查找主键这棵树，对于select * from 非主键=XX，基于非主键的查询有可能存在回表过程（回到主键索引树搜索的过程称为回表），因为非主键索引叶子节点仅存主键值，无整行全部信息。

### 非主键索引的查询一定会回表吗？

不一定，当查询语句的要求字段全部命中索引，不用回表查询。如select 主键 from 非主键=XX，此时非主键索引叶子节点即可拿到主键信息，不用回表。







## 树

### 简述B-Tree与B+树

B-Tree 是一种自平衡的多叉树。每个节点都存储关键字值。其左子节点的关键字值小于该节点关键字值，且右子节点的关键字值大于或等于该节点关键字值。

B+树也是是一种自平衡的多叉树。其基本定义与B树相同，不同点在于数据只出现在叶子节点，所有叶子节点增加了一个链指针，方便进行范围查询。

B+树中间节点不存放数据，所以同样大小的磁盘页上可以容纳更多节点元素，访问叶子节点上关联的数据也具有更好的缓存命中率。并且数据顺序排列并且相连，所以便于区间查找和搜索。

B树每一个节点都包含key和value，查询效率比B+树高。

### 为什么数据库不用红黑树用B+树

红黑树的出度为 2，而 B Tree 的出度一般都非常大。红黑树的树高 h 很明显比 B Tree 大非常多，IO次数很多，导致会比较慢，因此检索的次数也就更多。

B+Tree 相比于 B-Tree 更适合外存索引，拥有更大的出度，IO次数较少，检索效率会更高。

# 数据结构

## 简述数据结构栈

栈是一种线性表，其限制只能在表尾进行插入或删除操作。由于该特性又称为后进先出的线性表。

## **简述数据结构队列**

队列是一种先进先出的线性表。其限制只能在线性表的一端进行插入，而在另一端删除元素。

## 简述完全二叉树

一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。

## 简述解决Hash冲突的方法

开放定址法：当发生哈希冲突时，如果哈希表未被装满，那么可以把这个值存放到冲突位置中的下一个空位置中去

链地址法：对相同的哈希地址，设置一个单链表，单链表内放的都是哈希冲突元素

## 简述稳定排序和非稳定排序的区别

稳定排序：排序前后两个相等的数相对位置不变，则算法稳定 

非稳定排序：排序前后两个相等的数相对位置发生了变化，则算法不稳定

## 常见的稳定排序算法有哪些

插入排序、冒泡排序、归并排序

## 常见的不稳定排序算法有哪些

希尔排序、直接选择排序、堆排序、快速排序

## 简述插入排序

插入排序：每一趟将一个待排序记录按其关键字的大小插入到已排好序的一组记录的适当位置上，直到所有待排序记录全部插入为止。

排序算法稳定。时间复杂度 O(n²)，空间复杂度 O(1)。

## 简述直接选择排序

直接选择排序：每次在未排序序列中找到最小元素，和未排序序列的第一个元素交换位置，再在剩余未排序序列中重复该操作直到所有元素排序完毕。

排序算法不稳定。时间复杂度 O(n²)，空间复杂度 O(1)。

## 简述堆排序

堆排序：将待排序数组看作一个树状数组，建立一个二叉树堆。通过对这种数据结构进行每个元素的插入，完成排序工作。

排序算法不稳定，时间复杂度 O(nlogn)，空间复杂度 O(1)。

## 简述归并排序

归并排序：将待排序序列分成两部分，然后对两部分分别递归排序，最后进行合并。 排序算法稳定，

时间复杂度都为 O(nlogn)，空间复杂度为 O(n)。

## 简述图

图是由顶点集合和顶点之间的边集合组成的一种数据结构，分为有向图和无向图。

有向图：边具有方向性

无向图：边不具有方向性

## 简述邻接表

邻接表是通过链表表示图连接关系的一种方。对于表头结点所对应的顶点存在相邻顶点，则把相邻顶点依次存放于表头结点所指向的单向链表中。

## 简述图的深度优先搜索DFS

将图中每个顶点的访问标志设为 FALSE, 之后搜索图中每个顶点，如果未被访问，则以该顶点V0为起始点出发，访问此顶点，然后依次从V0的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和V0有路径相通的顶点都被访问到。

## 简述图的广度优先搜索

从图中的某个顶点V0出发，并在访问此顶点之后依次访问V0的所有未被访问过的邻接点，之后按这些顶点被访问的先后次序依次访问它们的邻接点，直至图中所有和V0有路径相通的顶点都被访问到。

# 设计模式

## 简述设计模式七大原则

开放封闭原则：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。

单一职责原则：一个类、接口或方法只负责一个职责，降低代码复杂度以及变更引起的风险。

依赖倒置原则：针对接口编程，依赖于抽象类或接口而不依赖于具体实现类。

接口隔离原则：将不同功能定义在不同接口中实现接口隔离。

里氏替换原则：任何基类可以出现的地方，子类一定可以出现。

迪米特原则：每个模块对其他模块都要尽可能少地了解和依赖，降低代码耦合度。

合成复用原则：尽量使用组合(has-a)/聚合(contains-a)而不是继承(is-a)达到软件复用的目的。

## 简述设计模式的分类

创建型模式：在创建对象的同时隐藏创建逻辑，不使用 new 直接实例化对象。有工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。

结构型模式：通过类和接口间的继承和引用实现创建复杂结构的对象。有适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

行为型模式：通过类之间不同通信方式实现不同行为。有策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

## 创建型

### 简述简单工厂模式

简单工厂模式指由一个工厂对象来创建实例,适用于工厂类负责创建对象较少的情况。例子：Spring 中的 BeanFactory 使用简单工厂模式，产生 Bean 对象。

### 简述工厂模式

工厂方法模式指定义一个创建对象的接口，让接口的实现类决定创建哪种对象，让类的实例化推迟到子类中进行。例子：Spring 的 FactoryBean 接口的 getObject 方法也是工厂方法。

### 简述抽象工厂模式

抽象工厂模式指提供一个创建一系列相关或相互依赖对象的接口，无需指定它们的具体类。例子：java.sql.Connection 接口。

## 结构型

### 简述代理模式

代理模式为其他对象提供一种代理以控制对这个对象的访问。优点是可以增强目标对象的功能，降低代码耦合度，扩展性好。缺点是在客户端和目标对象之间增加代理对象会导致请求处理速度变慢，增加系统复杂度。

静态代理：在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。

动态代理：程序运行期间动态的生成，所以不存在代理类的字节码文件。代理类和委托类的关系是在程序运行时确定。

## 行为型

### 简述模板模式

模板模式定义了一个操作中的算法的骨架，并将一些步骤延迟到子类，适用于抽取子类重复代码到公共父类。 可以封装固定不变的部分，扩展可变的部分。但每一个不同实现都需要一个子类维护，会增加类的数量。

# Redis

## Redis数据类型

String：字符串类型，最简单的类型 

Hash：类似于Map的一种结构。 

List：有序列表。

 Set:无序集合。 ZSet：带权值的无序集合，即每个ZSet元素还另有一个数字代表权值，集合通过权值进行排序。

## redis与memcache的区别

1.  redis处理网络请求采用单线程模型，而memcache采用多线程异步IO的方式
2.  redis支持数据持久化，memcache不支持
3.  redis支持的数据格式比memcache更多

## 简述缓存击穿

缓存击穿指缓存中没有数据，但数据库中有该数据。一般这种情况指特定数据的缓存时间到期，但由于并发用户访问该数据特别多，因此去数据库去取数据，引起数据库访问压力过大

## 简述缓存击穿的解决方法

1.  设置热点数据永远不过期。
2.  对并发读数据设置并发锁，降低并发性

## 简述缓存雪崩

缓存雪崩指缓存中一大批数据到过期时间，而从缓存中删除。但该批数据查询数据量巨大，查询全部走数据库，造成数据库压力过大。

## 简述缓存雪崩的解决方法

1.  缓存数据设置随机过期时间，防止同一时间大量数据过期。
2.  设置热点数据永远不过期。
3.  对于集群部署的情况，将热点数据均与分布在不同缓存中

## Redis有哪些集群部署方式

1.  主从复制
2.  哨兵模式
3.  Cluster集群模式

## 简述主从复制模式

在主从复制中，有主库（Master）节点和从库（Slave）节点两个角色。 从节点服务启动会连接主库，并向主库发送SYNC命令。

主节点收到同步命令，启动持久化工作，工作执行完成后，主节点将传送整个数据库文件到从库，从节点接收到数据库文件数据之后将数据进行加载。此后，主节点继续将所有已经收集到的修改命令，和新的修改命令依次传送给从节点，从节点依次执行，从而达到最终的数据同步。

通过这种方式，可以使写操作作用于主库，而读操作作用于从库，从而达到读写分离。